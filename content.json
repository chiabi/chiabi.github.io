{"meta":{"title":"Chiabi's dev blog","subtitle":"","description":"for posting my TIL, solutions of Algorithm quiz, posts about develop and etc","author":"chiabi","url":"http://chiabi.github.io"},"pages":[{"title":"About","date":"2018-06-09T12:48:18.769Z","updated":"2018-06-09T12:48:18.769Z","comments":true,"path":"about/index.html","permalink":"http://chiabi.github.io/about/index.html","excerpt":"","text":"안녕하세요. 개발자 chiabi의 블로그입니다. 이 블로그는 프론트엔드 개발자가 되기 위해 공부한 내용을 기록하는 블로그입니다.TIL과 알고리즘 퀴즈풀이 같은 데일리 기록과 배우면서 알게 된 내용을 카테고리별로 정리해서 올립니다. 글 내용에 오류가 있다면 편하게 댓글로 남겨주시기 바랍니다."}],"posts":[{"title":"TIL","slug":"TIL","date":"2018-08-08T14:48:20.000Z","updated":"2018-08-08T14:58:13.318Z","comments":true,"path":"2018/08/08/TIL/","link":"","permalink":"http://chiabi.github.io/2018/08/08/TIL/","excerpt":"","text":"오늘 한 일블로그 검색엔진 최적화대부분의 글이 알고리즘 문제 풀이나 TIL뿐이어서 블로그 검색엔진 최적화를 계속 제일 나중에 할 일로 미루다가 오늘 했다.hexo 블로그의 검색엔진 최적화 방법을 엄청 잘 정리해주신 글이 있어서 참고했다. 구글(Goolge) 사이트 등록(Search Console)과 검색엔진 최적화(SEO) Jest + Typescript + 연결리스트Jest로 테스트하는 걸 연습하면서 타입스크립트를 써보면서 연결리스트를 구현하고 있다. 연결리스트를 좀 잘못 생각하고 있던 게 있어서 다시 짜면서 만들어보고 있다.","categories":[{"name":"TIL","slug":"TIL","permalink":"http://chiabi.github.io/categories/TIL/"}],"tags":[{"name":"TIL","slug":"TIL","permalink":"http://chiabi.github.io/tags/TIL/"}]},{"title":"TIL","slug":"TIL","date":"2018-08-07T14:26:29.000Z","updated":"2018-08-08T14:56:07.566Z","comments":true,"path":"2018/08/07/TIL/","link":"","permalink":"http://chiabi.github.io/2018/08/07/TIL/","excerpt":"","text":"오늘 한 일You don’t know JS: 값 정리중내용은 어렵지 않은데, ‘슬롯’이라는 용어를 처음 봤다. 슬롯이 뭐지? 슬롯 머신??? 그런데 딱히 ‘array slot’, ‘javascript slot’ 뭐 이런 키워드로 검색해도 나오지 않는 것 보면 어떤 정식 명칭 같은 것은 아니고 그냥 슬롯 머신의 그 슬롯처럼 영어 뜻 그대로 ‘무언가 들어갈 자리, 구멍’의 의미로 쓴 것 같다. 그리고 검색하다가 나온건데 웹컴포넌트 관련해서 &lt;slot&gt;태그가 있다. HTML slot Jest와 타입스크립트 같이 쓰는 환경 구성이왕 Jest도 공부하면서 타입스크립트로 같이 공부하자는 생각에 일단 환경을 설정했다. 참고한 글 Jest로 TypeScript 학습테스트 환경 만들기 구입한 책 누구나 자료 구조와 알고리즘 누구나 쉽게 배우는 챗봇 서비스 (의도한 것은 아니지만 출판사가 다른데도 책 제목이 너무나 쉽게 가려는 나의 마음을 반영하는 것 같군…)서점 들린김에 읽어보다가 마음에 들어서 구입했다. 특히 챗봇은 취향저격이라. 공부하고 싶었던 것들이 한번에…(오오 폴리머!! 파이어베이스!!! 슬랙봇!!!) 책 따라서 만들어보고 리액트로도 도전해보는 걸 목표로 해야겠다. 나도 슬랙봇 만들어야지!!","categories":[{"name":"TIL","slug":"TIL","permalink":"http://chiabi.github.io/categories/TIL/"}],"tags":[{"name":"TIL","slug":"TIL","permalink":"http://chiabi.github.io/tags/TIL/"}]},{"title":"TIL","slug":"TIL","date":"2018-08-05T15:00:00.000Z","updated":"2018-08-07T06:49:57.717Z","comments":true,"path":"2018/08/06/TIL/","link":"","permalink":"http://chiabi.github.io/2018/08/06/TIL/","excerpt":"","text":"오늘 한 일Move Zeroes 파이썬 문제풀이어제 풀었던 Move Zeroes 문제에 파이썬 풀이도 추가했다. 파이썬으로 풀어보면서 리스트가 자바스크립트의 배열과 어떻게 다른지도 알아볼 수 있었다. 그리고 좀 신기했던 게 다른 사람 풀이를 보면서 또 찾아봤는데, 자바스크립트에서 분해대입이 아닌 이상은 변수를 콤마로 구분해 같이 선언하고 할당하는 게 안되는데, 파이썬에서는 가능하다.123const a = 1, b = 2; // 이것은 가능하지만const a, b = 1, 2; // 이것은 불가능하다. // SyntaxError: Missing initializer in const declaration 12345a = 1, b = 2 # 이것은 불가능하지만# SyntaxError: can't assign to literala, b = 1, 2# 이것은 가능하다 좀 헷갈리기는 하는데, 다른 언어를 배우면서 비교해보는 것도 재미있다. 파이썬에서 내 기준 묘한 사용법을 보게되면, ‘어 이거 자바스크립트는 안되지 않나?’하면서 테스트해보고 비교해보니까 같이 공부가 된다. You don’t know JS: 타입 정리카일 심슨의 You don’t know JS를 보면서 내용을 정리하고 이전에 배웠던 내용을 정리하고 있다.책을 읽으면서 정리하려고 했는데 번역이 조금 아쉬웠다. 예를 들면 ‘null은 falsy한 유일한 원시 값이지만, 타입은 object인 특별한 존재다.’라는 문장이 있었다. undefined도 0도 빈문자열도 다 falsy인 원시값인데 왜 저렇게 썼지 의문이 들어서 github에 올려져 있는 원문을 찾았다. null is the only primitive value that is “falsy” (aka false-like; see Chapter 4) but that also returns “object” from the typeof check. 라고 되어있는데 이문장을 ‘null은 falsy이면서, typeof 체크에서 object를 반환하는 유일한 원시값이다.’라고 번역했어야 되지 않을까 싶다.(이문장도 매끄러운 번역인지는 잘 모르겠다. 부끄럽게도 영어를 잘 못한다…)그래서 원문이랑 책을 번갈아 보기로 했다.자바스크립트에 대한 이해가 없었을 때는 좀 어렵게 느껴진 책이었는데, 지금은 놓치고 있는 자바스크립트의 특성을 하나씩 짚어내면서 더 깊이 다지는 느낌으로 읽을 수 있게 되었다.","categories":[{"name":"TIL","slug":"TIL","permalink":"http://chiabi.github.io/categories/TIL/"}],"tags":[{"name":"TIL","slug":"TIL","permalink":"http://chiabi.github.io/tags/TIL/"}]},{"title":"TIL","slug":"TIL","date":"2018-08-05T14:36:59.000Z","updated":"2018-08-07T06:30:15.892Z","comments":true,"path":"2018/08/05/TIL/","link":"","permalink":"http://chiabi.github.io/2018/08/05/TIL/","excerpt":"","text":"오늘 한 일이력서 작성이력서 작성하는 게 공부하는 것보다 제일 어려운 것 같다. 특히 자소서…. Move Zeroes 알고리즘 문제풀이나는 이 문제에서 splice와 push 메서드를 빼면 원본 배열의 변형을 주면서 어떻게 풀 수 있을까 생각이 잘 안났는데, 내가 loop를 한번만 도는 것에만 집중해서 그런 것 같다. 다른 사람의 풀이를 보니 for문을 두번 사용했지만 메서드 없이 인덱싱만으로 풀어냈다. 그리고 2번째 for문은 0이 들어갈 자리의 개수만큼만 도니까 그리 비효율적이지도 않다.","categories":[{"name":"TIL","slug":"TIL","permalink":"http://chiabi.github.io/categories/TIL/"}],"tags":[{"name":"TIL","slug":"TIL","permalink":"http://chiabi.github.io/tags/TIL/"}]},{"title":"Moved ZeroS","slug":"moveZeroes","date":"2018-08-05T14:35:38.000Z","updated":"2018-08-07T06:07:16.035Z","comments":true,"path":"2018/08/05/moveZeroes/","link":"","permalink":"http://chiabi.github.io/2018/08/05/moveZeroes/","excerpt":"","text":"Given an array nums, write a function to move all 0’s to the end of it while maintaining the relative order of the non-zero elements. Example: Input: [0,1,0,3,12] Output: [1,3,12,0,0] Note:You must do this in-place without making a copy of the array.Minimize the total number of operations. 나의 풀이JavaScript원본 배열에 변형을 주는 splice() 메서드와 push() 메서드를 사용했다. 배열 요소가 0일경우 splice 메서드를 통해 해당 요소는 삭제하고 push 메서드를 통해 0을 배열의 뒤쪽에 추가해줬다.12345678910111213// 68msvar moveZeroes = function(nums) &#123; let i = 0, l = nums.length; while(i &lt; l) &#123; if(nums[i] === 0) &#123; nums.splice(i, 1); nums.push(0); l--; &#125; else &#123; i++; &#125; &#125;&#125;; Python자바스크립트에서 푼 풀이방법으로 list의 메서드를 이용해 풀었다.1234567891011121314class Solution: def moveZeroes(self, nums): \"\"\" :type nums: List[int] :rtype: void Do not return anything, modify nums in-place instead. \"\"\" l = len(nums) for i in range(l): if nums[i] == 0: nums.remove(0) nums.append(0) l -= 1 else: i += 1 count() 메서드를 통해 0인 요소의 개수를 세어 그만큼 for문을 돌리는 방법을 사용했다.12345678910class Solution: def moveZeroes(self, nums): \"\"\" :type nums: List[int] :rtype: void Do not return anything, modify nums in-place instead. \"\"\" l = nums.count(0) for i in range(l): nums.remove(0) nums.append(0) 다른 사람 풀이JavaScript0이 아닌 요소만 다시 배열에 순서대로 담아주고, index부터 총 길이까지 0을 추가해줬다.12345678910111213var moveZeroes = function(nums) &#123; var index = 0 for (var i = 0; i &lt; nums.length; i++) &#123; if (nums[i] != 0) &#123; nums[index] = nums[i]; index++; &#125; &#125; for (var i = index; i &lt; nums.length; i++) &#123; nums[i] = 0; &#125;&#125;; Python1234567891011class Solution: def moveZeroes(self, nums): \"\"\" :type nums: List[int] :rtype: void Do not return anything, modify nums in-place instead. \"\"\" idx = 0 for i in range(len(nums)): if nums[i] != 0: nums[idx], nums[i] = nums[i], nums[idx] idx += 1 자바스크립트에서는 객체와 변수의 분해대입이 아니라면 변수를 ,(콤마)로 구분해 값을 한번에 할당할 수가 없는데, 파이썬에서는 가능하다.12345678const a, b = 1, 2; // 이것은 문법적으로 허용되지 않고// Uncaught SyntaxError: Missing initializer in const declarationconst a = b = 1; // 이것은 b가 전역 변수가 되기 때문에 좋은 방법이 아니다.// 대신 다음과 같은 객체와 배열의 분해대입은 가능하다.const [a, b] = [1, 2]const &#123;a, b&#125; = &#123;1, 2&#125; 파이썬에서는 다음과 같은 방법으로 변수를 만들 수 있다.12345a, b = 1, 2a, b = (1, 2)(a, b) = 1, 2[a, b] = [1, 2]a = b = 'python'","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://chiabi.github.io/categories/Algorithm/"}],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://chiabi.github.io/tags/algorithm/"},{"name":"leetcode","slug":"leetcode","permalink":"http://chiabi.github.io/tags/leetcode/"}]},{"title":"TIL","slug":"TIL","date":"2018-08-04T14:12:44.000Z","updated":"2018-08-04T16:59:11.983Z","comments":true,"path":"2018/08/04/TIL/","link":"","permalink":"http://chiabi.github.io/2018/08/04/TIL/","excerpt":"","text":"오늘 한 일House Robber 알고리즘 문제풀이프로그래머스의 땅따먹기 문제의 악몽이… 생각보다 어려워서 조금 시간이 걸렸다. 처음에는 막연히 filter랑 reduce 같은 걸 써야하나?라고 생각했는데 그보다는 더 복잡했다. 단순히 하나를 건너뛰는게 아니라 [2, 1, 1, 2]같이 0번째와 3번째가 아니라 0번째와 4번째의 조합이 가장 큰 수인 경우도 있어서 어떤 규칙을 찾아야했다.leetcode에서 Dynamic Programming으로 분류되어 있길래 관련해서도 정리해봤다. 정리하면서 내가 쓴 방법이 메모이제이션임을 알게되었고 피보나치 수열을 예로 설명을 정리해보니 메모이제이션에 대해 이해가 되었다. 블로그 수정 헤더, follow 버튼, 링크 컬러 수정 하단 탑 버튼 디자인 수정 블록체인 이해하기블록체인을 기반으로 하겠다는 기술도 기업도 많다. 내가 블록체인에 대해 알고 있는 것은 조작이 어려워 안전하고 익명이지만 추적가능하고 거래 투명성을 보장한다는 것 정도이다. 블록체인의 기술 구현보다 이 기술의 실효성에 대해 이해가 잘 안되어서 오늘은 관련 글을 이것저것 찾아서 읽어봤다. 블록체인으로 가능한 비즈니스 모델이 이해가 안되어서 참고할만한 포스팅 블록체인, 미디어의 미래를 말하다 블록체인 기술의 실체 그리고 미래 블록체인에서 가능한 재미난 비즈니스 모델 그림으로 쉽게 이해하기 초딩도 이해하는 블록체인 : 블록체인과 비트코인 좀 더 깊게 이해하기 원리부터 파악하는 비트코인 블록체인 한번에 이해하기 길위의 개발자 - 자바스크립트로 블록체인 구현강좌 읽으면서도 계속 의문점이 들었던 거는 블록체인의 본질이라고 할 수 있는 탈중앙화의 의미 때문이었는데, 어떤 곳에서 플랫폼을 제공하고 그 플랫폼에서 이루어지는 거래의 수수료를 떼는 구조라면 또다른 중앙화랑 뭐가 다른가 싶어서였다. 그런데 이 부분은 나는 경제와 권력의 관점에서 진정한 탈중앙화의 의미에 너무 치중해서 생각하고 있어서 그런 것 같다. 데이터의 분산과 그에 따라 더 보안을 보장할 수 있는 것, 그리고 기여자들에게도 그 대가가 돌아가는 구조라는 점에서 효용성을 봐야할 것 같다. 그리고 또 하나는 속도인데… 이거는 EOS에 대해서도 좀 더 찾아봐야겠다. drafts에 글 배포 잊지말자;;","categories":[{"name":"TIL","slug":"TIL","permalink":"http://chiabi.github.io/categories/TIL/"}],"tags":[{"name":"TIL","slug":"TIL","permalink":"http://chiabi.github.io/tags/TIL/"}]},{"title":"House Robber","slug":"HouseRobber","date":"2018-08-04T02:01:41.000Z","updated":"2018-08-04T16:16:50.067Z","comments":true,"path":"2018/08/04/HouseRobber/","link":"","permalink":"http://chiabi.github.io/2018/08/04/HouseRobber/","excerpt":"","text":"leetcode 문제링크 You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security system connected and it will automatically contact the police if two adjacent houses were broken into on the same night. Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police. Example 1: Input: [1,2,3,1] Output: 4 Explanation: Rob house 1 (money = 1) and then rob house 3 (money = 3).Total amount you can rob = 1 + 3 = 4. Example 2: Input: [2,7,9,3,1] Output: 12 Explanation: Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1).Total amount you can rob = 2 + 9 + 1 = 12. 나의 풀이문제에 주어진 배열이 [1, 2, 3]이라고 했을 때 1 + 3과 2를 비교하게 되고, [1, 2, 3, 4]일 경우는 1 + 3과 2 + 4를 비교하게 되는데 그러면 홀수번과 다음 수를 비교할 때는even = Math.max(1 + 3, 2)이 되고, 짝수번의 요소와 다음 수를 비교하면odd = Math.max(4, 2 + 4)가 된다. 이런 규칙을 이용해서 푸는데, 만약 빈배열이거나 요소가 1개일 경우를 위해even과odd`는 0을 기본값으로 할당해줬다. 12345678910111213// 60msvar rob = function(nums) &#123; let even = 0; let odd = 0; for (let i = 0; i &lt; nums.length; i++) &#123; if (i % 2 === 0) &#123; even = Math.max(even + nums[i], odd); &#125; else &#123; odd = Math.max(even, odd + nums[i]); &#125; &#125; return Math.max(even, odd)&#125; 예전에 푼 프로그래머스 땅따먹기 문제랑 비슷한 것 같다. 이것도 너무 오래 걸렸다. 이런 유형의 알고리즘을 Dynamic Programming(DP)이라고 하는 것 같다. 다른 사람 풀이빈배열, 배열 요소가 하나일 때, 2개 일때는 따로 값을 반환하고, 3개 이상일 경우부터 n: Max(n+s(n-2), s(n-1))같은 규칙을 따른다. 123456789101112131415161718192021222324252627282930var rob = function(nums) &#123; // 1: 1 // 1,2: Max(1, 2) // 1,2,3: Max(3+s([1]), s([1,2])) // 1,2,3,4: Max(4+s([1,2]), s([1,2,3])) // n: Max(n+s(n-2), s(n-1)) if(!nums.length) &#123; return 0; &#125; if(nums.length === 1) &#123; return nums[0]; &#125; if(nums.length === 2) &#123; return Math.max(nums[0], nums[1]); &#125; const dp = []; dp[0] = nums[0]; dp[1] = Math.max(nums[0], nums[1]); // dp[2] = Math.max(nums[2] + dp[0], dp[1]); for(let i = 2; i &lt; nums.length; i++) &#123; dp[i] = Math.max(nums[i]+dp[i-2], dp[i-1]); &#125; return dp[dp.length - 1];&#125;; Dynamic Programming(DP)동적 프로그래밍 문제를 여러 개의 하위 문제로 나누어 푼 다음, 그것을 결합하여 최종적인 목적에 도달하는 방법으로 하위 문제의 값을 저장해두어(memozation) 그 하위 문제를 반복해서 풀어야 하는 경우 다시 계산하지 않고 재사용하는 식으로 계산 횟수를 줄일 수 있다. 모든 방법을 일일이 검토해 그 중 최적의 풀이법을 찾아내야 하기 때문에 최적의 방법(혹은 최단 경로)를 찾아내기 위한 시간이 걸리지만 그 결과는 가장 최적의 방법(최단 경로)라고 장담할 수 있다. 이를 이용한 알고리즘으로 최장 공통 부분 수열, 벨만-포드 알고리즘, 배낭문제 등이 있다. 피보나치 수열 문제의 경우 재귀적으로 다음과 같이 풀 수 있다.10, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233... 1234const fibo = (n) =&gt; &#123; if (n &lt;= 1) return n; return fibo(n - 1) + fibo(n - 2);&#125; 이 경우 fibo(5)를 구할 경우 다음과 같이 계산되는데, fibo(n)이 중복되어 계산되는 부분이 있어서, 전체적인 계산 속도를 떨어뜨린다.(이 알고리즘의 시간 복잡도는 지수함수가 된다.) fibo(5) fibo(4) + fibo(3) (fibo(3) + fibo(2)) + (fibo(2) + fibo(1)) ((fibo(2) + fibo(1)) + (fibo(1) + fibo(0))) + ((fibo(1) + fibo(0)) + fibo(1)) (((fib(1) + fib(0)) + fib(1)) + (fib(1) + fib(0))) + ((fib(1) + fib(0)) + fib(1)) 이를 계산했던 값을 저장하는 메모이제이션을 이용해 동적 프로그래밍 방법으로 풀어본다면 다음과 같이 풀 수 있다. 이렇게 하면 중복되는 계산이 줄어든다.(시간 복잡도는 O(n)이 된다.)123456789101112const fibonacci = (n) =&gt; &#123; const memo = &#123;0: 0, 1: 1&#125;; const fibo = (n) =&gt; &#123; if (n &lt;= 1 || memo[n]) &#123; return memo[n] &#125; else &#123; memo[n] = fibo(n - 1) + fibo(n - 2); return memo[n]; &#125; &#125;; return fibo(n);&#125; 참고 Wikipedia - Dynamic programming GeeksforGeeks - Dynamic Programming","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://chiabi.github.io/categories/Algorithm/"}],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://chiabi.github.io/tags/algorithm/"},{"name":"leetcode","slug":"leetcode","permalink":"http://chiabi.github.io/tags/leetcode/"}]},{"title":"TIL","slug":"TIL","date":"2018-08-02T15:00:00.000Z","updated":"2018-08-04T16:57:24.596Z","comments":true,"path":"2018/08/03/TIL/","link":"","permalink":"http://chiabi.github.io/2018/08/03/TIL/","excerpt":"","text":"오늘 한 일Jest 공부하기자료구조를 만들어보면 테스트를 어떻게 할 지 고민을 했다. 처음에는 HTML 파일을 만들어서 script로 넣어서 콘솔에 넣을까 생각했다. ES6를 사용하니까 babel과 parcel 문서를 보고 환경을 만들다가 javascript-algorithm 처럼 테스트 환경을 만들어 보는 게 나을 것 같아서 Jest로 테스트 환경을 만들기로 했다. Jest 문서의 Getting Started를 참고해서 sum 함수를 테스트 해보려다가 다음과 같은 에러가 발생했다. Jest 깃헙의 이슈를 참고해서 package.json에 다음과 같이 testURL값을 http://localhost/ 로 해서 jest 설정 부분을 추가했다. 해당 옵션은 ‘jsdom’환경의 URL을 설정한다고 한다. 123456&#123; \"jest\": &#123; \"verbose\": true, \"testURL\": \"http://localhost/\" &#125;,&#125; 이 부분은 jest.config.js파일을 만들어서 다음과 같이 추가해도 된다.1234module.exports = &#123; verbose: true, testURL: \"http://localhost/\"&#125;; verbose는 테스트 결과를 자세히 보고할 지 여부인데 기본값이 false라서 같이 추가해줬다. Configuring Jest 영어학원 등록나는 외국을 안 나갈거니까 영어 따위는 필요없다고 호기롭게 말했던 학생때의 나를 때려주고 싶다. 사실 개발을 하게 될 줄도 몰랐지만… 영어와 뗄래야 뗄 수 없는 관계가 될 줄도 몰랐다.개발 공부하면서 영어 공부의 필요성을 무지막지하게 느끼고 있다. 아직까지는 수능영어 공부할 때와 공무원 영어 공부하면서 얻은 독해 실력과 구글 번역기로 연명하고 있는데, 좀 더 빨리 읽고 싶고, 의미를 더 잘 이해하고 싶고 무엇보다 자막없는 컨퍼런스 영상을 이해하고 싶다. 그리고 커밋 메시지 비문없이 영어로 적고 싶다!","categories":[{"name":"TIL","slug":"TIL","permalink":"http://chiabi.github.io/categories/TIL/"}],"tags":[{"name":"TIL","slug":"TIL","permalink":"http://chiabi.github.io/tags/TIL/"}]},{"title":"TIL","slug":"TIL","date":"2018-08-01T15:00:00.000Z","updated":"2018-08-04T16:12:55.923Z","comments":true,"path":"2018/08/02/TIL/","link":"","permalink":"http://chiabi.github.io/2018/08/02/TIL/","excerpt":"","text":"오늘 한 일자료구조 연결리스트 풀이 javascript-algorithms : Linked List leetcode : Linked List 연결리스트 설명부분만 먼저 보고, leetcode에 관련 문제가 있어서 먼저 구현해봤다. 연결리스트 설명이 블록체인에 대해 유튜브에서 간단히 설명했을때의 구조와 비슷한 것 같아서 흥미로웠다.처음에 설명만 읽어서는 배열 안에 넣어야하나라고 생각했다. 그런데 배열 자체가 이미 push, pop을 할 수 있고, 인덱스로 해당 값을 구할 수 있다. 그래서 ZeroCho님의 블로그에서의 설명을 더 참고했다. 자바스크립트는 이미 배열로 연결 리스트가 구현되어 있어서, 객체로 만들어본다고 했다. 거기서 아이디어를 얻어서 leetcode 문제를 바탕으로 풀어봤다. 풀이는 github TIL 레포지토리에 올렸는데 좀 더 정리되면 블로그에 올려야겠다.","categories":[{"name":"TIL","slug":"TIL","permalink":"http://chiabi.github.io/categories/TIL/"}],"tags":[{"name":"TIL","slug":"TIL","permalink":"http://chiabi.github.io/tags/TIL/"}]},{"title":"keyboardRow","slug":"keyboardRow","date":"2018-08-01T06:56:42.000Z","updated":"2018-08-01T08:54:36.361Z","comments":true,"path":"2018/08/01/keyboardRow/","link":"","permalink":"http://chiabi.github.io/2018/08/01/keyboardRow/","excerpt":"","text":"leetcode 문제링크 Given a List of words, return the words that can be typed using letters of alphabet on only one row’s of American keyboard like the image below. Example 1: Input: [“Hello”, “Alaska”, “Dad”, “Peace”] Output: [“Alaska”, “Dad”] Note: You may use one character in the keyboard more than once. You may assume the input string will only contain letters of alphabet. 나의 풀이every메소드를 써서 키보드 배열 중 모든 문자열이 속하는 배열이 있는 지 확인하는 부분에서 반복문을 쓸까 하다가 키보드 배열의 값은 변경될 일이 없을 것 같고 반복문 쓰면서 every의 반환값을 어딘가에 저장해두는 것이 더 좋은 방법 같지는 않아서 다음과 같이 풀었다. 123456789101112131415// 48msconst keyboard = [ ['Q', 'W', 'E', 'R', 'T', 'Y', 'U', 'I', 'O', 'P'], ['A', 'S', 'D', 'F', 'G', 'H', 'J', 'K', 'L'], ['Z', 'X', 'C', 'V', 'B', 'N', 'M'],];var findWords = function(words) &#123; return words.filter(item =&gt; &#123; const itemArr = item.toUpperCase().split(''); return itemArr.every(item =&gt; keyboard[0].includes(item)) || itemArr.every(item =&gt; keyboard[1].includes(item)) || itemArr.every(item =&gt; keyboard[2].includes(item)); &#125;)&#125;; 정규식이랑 match() 메소드, some()메소드를 이용해 다른 방법으로 풀어보았다. result에 한번 match의 반환값을 저장할 필요가 있었는데, join()으로 다시 문자열 결합할 때, match의 반환값이 배열이 아니라 null일때도 있기 때문이다. 12345678910// 52msvar findWords = function(words) &#123; const keyboards = [/[QWERTYUIOP]/ig, /[ASDFGHJKL]/ig, /[ZXCVBNM]/ig]; return words.filter(item =&gt; &#123; return keyboards.some(row =&gt; &#123; const result = item.match(row); return result &amp;&amp; result.join('') === item &#125;); &#125;)&#125;; 다른 사람 풀이정규식을 굉장히 잘 사용한 풀이인 것 같다. ^과 $을 이용해서 문자셋으로만 구성된 단어인지 여부를 RegExp test() 메소드를 통해서 bool값으로 반환하도록 했다.123456789101112var findWords = function(words) &#123; return words.filter((w) =&gt; &#123; // remove word from array if it fails matching all three rows if ( !/^[qwertyuiop]*$/i.test(w) &amp;&amp; !/^[asdfghjkl]*$/i.test(w) &amp;&amp; !/^[zxcvbnm]*$/i.test(w) ) return false; return true; &#125;);&#125;;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://chiabi.github.io/categories/Algorithm/"}],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://chiabi.github.io/tags/algorithm/"},{"name":"leetcode","slug":"leetcode","permalink":"http://chiabi.github.io/tags/leetcode/"}]},{"title":"2018 장고걸스 서울 워크샵 후기","slug":"djangogirls","date":"2018-07-31T04:03:45.000Z","updated":"2018-08-08T14:30:18.292Z","comments":true,"path":"2018/07/31/djangogirls/","link":"","permalink":"http://chiabi.github.io/2018/07/31/djangogirls/","excerpt":"","text":"기다리던 장고걸스 서울 워크샵 소식이 올라왔을 때 기쁘면서도 걱정이 되었다. 나는 파이썬과 장고는 생소하지만, 프로그래밍을 전혀 모르는 사람은 아니며 퍼블리셔로는 3년을 일했는데 개발 입문자를 위한 이 워크샵에 당첨될 수 있을까? 그래서 참가 신청 때 개발 경험이 있는지 등을 묻는 질문지를 보면서 이거 살짝 뻥을 쳐야하는 건가 생각했다. 차마 그럴 수 없어서 매우 솔직하게 썼는데 ‘장고걸스에서의 경험을 나누고 싶고 깃헙을 관리하고 있고 개발 블로그도 운영하고 있습니다’라는 나의 어필이 통한 것일까 당첨이 되었다. (야호!)그리고 스쿨 동기들에게도 슬랙으로 워크샵 소식을 공유했더니 몇분이 신청해서 같이 참여하게 되었다. 장고걸스는 개발 입문자가 가장 편안한 마음으로 참여할 수 있는 개발 행사이다.2018년의 나의 다짐은 ‘마크업만이 아니라 스크립트도 잘 다루고 최신 프론트엔드 트렌드도 따라갈 수 있는 개발자가 되자’였다. 그래서 3년을 다녔던 웹 에이전시를 나오기로 했고, 눈여겨보고 있던 패스트캠퍼스의 프론트엔드 스쿨 과정을 등록했다. 마침 시기도 적절한 게 퇴사일과 학원 개강일 사이에 2주 정도의 텀이 있었다. 학원에서는 각종 개발 커뮤니티와 밋업, 컨퍼런스에 참여하기를 권장했고 실제로 그렇게 열심히 살아야만 이 시대의 개발자(적어도 내가 이상으로 삼았던 개발자)로 살아갈 수 있는 것 같았다. 일단 페이스북 그룹이나 슬랙에 가입했다. 커뮤니티가 다양한 만큼 종종 다양한 행사 소식도 올라왔다. 간단히 맥주를 마시면서 개발에 관한 얘기를 나눠보자는 모임부터 해마다 정기적으로 열리는 것 같은 컨퍼런스 소식까지 다양했다. 그런데 그 많은 행사 중에 어느 것 하나 선뜻 참여할 용기가 나지 않았던 이유는 내가 꿔다놓은 보릿자루같이 굴 것 같아서였다. ‘아는 사람 하나 없이 뻘쭘하게 있을 것 같아.’‘대화하는데 내가 너무 몰라서 못 알아들으면 어떡하지?’‘내가 너무 바보 같은 질문을 하면 어쩌지?’‘입문자를 위한 모임은 없나?’ 이런 나의 걱정을 해소해주고 편안한 마음으로 참여할 수 있는 개발 행사가 장고걸스 워크샵이었다. 장고걸스 워크샵에서 가장 좋았던 점은 워크샵 기간 동안 지켜줘야 할 점에 대해 알려주는데, 그중 참석자는 어떠한 질문이라도 (너무 기초적이라 바보같이 느껴질 것 같은 질문이라도) 할 수 있다는 것이다. 요즘은 개발 커뮤니티에서도 어느 정도 자정하는 분위기인데, 가끔 너무 기초적인 것을 물어보는 사람에게 그 정도도 검색해서 찾아보지 않으냐며 날카롭게 구는 사람들이 몇몇 있다. 모르는 사람의 가장 큰 어려움은 이 모르는 걸 어떤 방법을 써야 해결할 수 있는지조차 모른다는 것이다. 아는 사람들이야 ‘“구글”에 “영어”로 이런 “키워드”로 검색하면 다 나와’, ‘“stack overflow”에 가면 다 있어’라고 말하지만, 그것조차 모를 수도 있는 법이다. 실제로 나는 웹 쪽으로 전향하기 전, 우체국에서 일할 당시만 해도 크롬은 안 썼다. 검색은 모두 네이버를 통해 이뤄졌고 어릴 때는 익스플로러가 업데이트되어서 UI가 조금이라도 바뀌면 화를 냈었다. 내가 그 사람 옆에서 성장 과정을 계속 지켜보지 않은 이상은 상대가 어느 정도 알 것이라는 판단을 섣부르게 해서는 안 된다. 아무튼, 이런 나의 여과 없이 나오는 질문에도 친절히 알려주신 이재열 코치님께 감사드린다. 장고걸스에는 훌륭하고 친절한 코치님이 많이 계신다. 모른다고 걱정하지 말자행사장에 딱 들어섰을 때 느낀 것은 ‘많다! 사람이 많다!!’였다. 파란 옷을 입은 워크샵 신청자도 많은데 흰옷을 입고 있는 코치님이나 검은 옷을 입고 있는 관계자분도 많았다. 조를 꾸려서 한 조에 신청자 3명 정도에 코치님이 1명 이상이 붙어서 진행하는데, 그렇게 구성된 조가 20팀 이상이었던 것 같다.워크샵 첫날(7/20)은 7시에 시작되어 2시간 정도 파이썬을 설치하거나 에디터를 설치하는 것 같은 기본적인 개발환경을 세팅했다. 두 번째 날(7/21)에 본격적으로 장고걸스 튜토리얼을 따라 하면서 장고로 블로그를 만들었다. 우리 조는 나를 포함해 개발을 배워보셨거나 배우고 있는 분들이어서 어쩌다 보니 굉장히 빠르게 진행되어 심화 튜토리얼까지 진행해버렸지만, 중간중간 막히는 부분도 있었다. 나의 경우는 내가 찾을 수 없는 오류가 발생하는 경우거나 git에서 실수해버린 경우였는데 코치님이 팀 테이블 주위를 열심히 뛰어다니면서 문제가 발생할 때마다 같이 봐주시고 해결해주셨다. 그리고 블로그를 만들면서 개인적으로 파이썬 문법과 장고에 대해 어느 부분까지가 장고의 기능이고, 파이썬의 문법인지 궁금한 점을 여쭤봤는데 매우 친절하고 쉽게 알려주셨다.특히 첫날에 MVC에 대해 설명해주셨는데, 사실 이전에는 MVC, MVVM 등의 아키텍처 패턴에 대한 이해가 많이 부족했다. 리액트는 뷰만 담당하는 라이브러리이고 앵귤러는 프레임워크다라는 설명을 들었을 때도 앵귤러에 대한 경험과 이해가 없다 보니 어떤 점이 다른 것인지 이해하기는 힘들었다. 관련해서 글을 찾아봐도 이해를 잘 못 했는데, 이재열 코치님의 설명을 듣고 장고걸스 튜토리얼을 따라 해 보면서 MVC 패턴이나 프레임워크란 것이 어떤 것인지 이해하게 되었다. 장고걸스 워크샵의 좋은 점은 내가 혼자서 한다면 몇 날 며칠이 걸릴지도 모르는 문제를 코치의 도움을 받아 빠르게 해결할 수 있다는 것이다. 혼자 공부하는 것에도 장점은 있다. 해결 방법을 찾는 과정 또한 공부일 것이고, 문제 해결 능력을 키울 수 있다. 해결했다는 성취감 역시 얻을 수 있다. 단점은 매우 많은 삽질을 해야 하고 엄청나게 시간을 낭비할지 모른다는 것이다. 이전에 장고걸스 튜토리얼을 따라 해보려다 포기한 이유는 튜토리얼 자체가 ‘이 정도는 아시죠?’ 같은 느낌이 없지 않아 있는 데다가 그 이 정도를 맞추기 위해 어디부터 공부해야 할 지 감이 안 잡히고, 오류 상황이 발생했을 때 그걸 풀 능력이 내게 부족해서 gulp와 Sass를 처음 익힐 때처럼 매우 고통의 시간이 될 것 같은 예감이 들어서였다. 그래서 스쿨과정이 끝날 때쯤에는 어느 정도 스크립트에 익숙해져 있을 테니 그때 다시 도전하자는 마음으로 일단 접어두었었다.단순히 따라하는 것뿐이더라도 개발의 한 사이클을 경험해보고 결과물을 만들게 되면 앞으로의 공부에 많은 도움이 된다. 그런 점에서 장고걸스는 개발 입문자에게 (혹은 나처럼 파이썬/장고 입문자에게) 굉장히 좋은 기회인 것 같다. 마치며오늘도 작문 실력을 늘려야겠다는 깊은 반성을 하며…장고걸스 워크샵을 신청한 계기는 ‘잘 만들어진 튜토리얼을 제공한다해도 누구의 도움도 없이 생소한 언어와 생소한 기술을 사용해 보는 것은 굉장히 오랜 시간이 걸리니까 워크샵을 통해 코치님들의 도움을 받아 한 사이클을 빠르게 경험해보자’였다. 실제로 코치님의 도움으로 튜토리얼을 따라하는데 큰 어려움은 없었다. 장고의 일부를 경험한 것이지만 웹 프레임워크라는 것이 어떤 것인지 경험해 볼 수 있어서 그것만으로도 굉장히 유익했다.그런데 그런 목표 성취 이상의 경험이었다. 세마나 형식의 컨퍼런스 외에 이런 소통을 통한 커뮤니티 행사에 처음 참여해 본 것이었고 나 스스로 이전과 다르게 외향적으로도 적극적인 사람이 되었구나를 느꼈다. 그리고 앞으로 개발 커뮤니티의 행사에 참여할 용기를 얻었다. 다음에는 장고걸스에 코치로 참여하는 것을 목표로 해야겠다. django girls seoul django girls seoul : 페이스북 커뮤니티 장고걸스 튜토리얼 장고걸스 튜토리얼 : 심화 나의 장고 블로그 결과물","categories":[{"name":"log","slug":"log","permalink":"http://chiabi.github.io/categories/log/"}],"tags":[{"name":"Django Girls","slug":"Django-Girls","permalink":"http://chiabi.github.io/tags/Django-Girls/"},{"name":"장고걸스","slug":"장고걸스","permalink":"http://chiabi.github.io/tags/장고걸스/"}]},{"title":"TIL","slug":"TIL","date":"2018-07-28T08:15:30.000Z","updated":"2018-07-31T04:02:46.645Z","comments":true,"path":"2018/07/28/TIL/","link":"","permalink":"http://chiabi.github.io/2018/07/28/TIL/","excerpt":"","text":"오늘 한 일엔트리감기와 올해 4학년이 된 사촌동생이 함께 찾아왔다.(신난다) 자는 동안은 감기로 죽어있고, 깨어있는 동안은 열정적인 여동생과 놀아줘야했다. 다음주 내내 휴가를 낸 언니는 그것만 바라보며 약간 득도한 모양이다. ‘치킨차차’라고 기억력 향상에 매우 유익한 보드게임이 있는데, 아무도 나와 놀아주지 않아서 구석에서 썩고 있던 것을 사촌동생이 잘도 찾아내서 끝나지 않을 것만같은 꼬리잡기 릴레이를 했다. 동생의 흥미를 다른 곳으로 돌리기 위해 게임 만드는 거 좋아하냐는 질문으로 약을 팔면서 컴퓨터 앞에 앉혔다. 다행히 게임 만드는 게 재미있을 것 같다며 흥미로워 했다. 엔트리는 네이버에서 홍보할 당시에 소프트웨어적 사고력을 키워준대서 해봤었는데, 오랜만에 들어오니 많이 체계적으로 바껴있고 작품 공유하기에는 어린애들이 만든게 맞나 싶을 정도로 꽤 잘 만든 것도 있었다. 학습하기를 따라하도록 하고서 지켜봤는데, 학습용이라는 목적에 맞게 단계적으로 진행하도록 설명 팁이 계속 제공되었다.학습하기 외에 작품만들기를 이용하면, 학습하기에서 학습했던 것을 토대로 자신만의 창의적인 작품을 만들어 볼 수 있는데, 이걸 봤다가 갑자기 모르는 UI가 급 보여지니까 어렵게 느껴졌는지 사촌동생의 흥미 역시 급 하락해버렸다… 액괴 영상에 밀려서 더이상 진행하지는 못했지만, 학습하기에서 반복문 안에 로직을 넣는 것이 나왔었는데, 이런 사고력을 어릴때부터 키운다면 나중에 다른 언어를 공부한다해도 크게 어려움이 없겠구나 생각되었다. 요즘 초등학생들은 이런 엔트리나 스크래치를 이용해서 코딩교육을 한다고 들었는데, 나중에라도 동생이 이쪽으로 흥미가 생기거나 필요하게 되면 나한테 도움을 구해줬으면 좋겠다. 그리고 꼭 개발자가 되고싶지 않더라도 경험이란 것은 앞으로의 선택에 중요한 밑거름이 되니까 도움이 되었으면 좋겠다. 갑자기 고등학생때 RPG 쯔꾸루로 게임을 만들어본다고 알지도 못하는 스크립트를 Ctrl + C / V 하면서 혼자 삽질했던 기억이…","categories":[{"name":"TIL","slug":"TIL","permalink":"http://chiabi.github.io/categories/TIL/"}],"tags":[{"name":"TIL","slug":"TIL","permalink":"http://chiabi.github.io/tags/TIL/"}]},{"title":"TIL","slug":"TIL","date":"2018-07-27T14:13:07.000Z","updated":"2018-07-28T09:02:52.536Z","comments":true,"path":"2018/07/27/TIL/","link":"","permalink":"http://chiabi.github.io/2018/07/27/TIL/","excerpt":"","text":"오늘 한 일퍼블리싱 외주 완료오늘은 업체에 찾아가서 마지막 마무리 작업을 했다. 내 마크업에 기존 개발중인 기능을 적용해야 하는데, UI가 수정되기도 해서 추가 작업을 했다. 수정요청이 좀 많아서 6시까지 완료할 수 있을까 조금 걱정했는데, 업체 개발자와 협의해서 먼저 개발해야하는 기능부터 수정해서 넘겨주는 식으로 작업을 진행해서 다행히 시간내에 완료할 수 있었다. 디자인도 외주를 맡긴 상황이라 기획이나 디자인이 빠르게 넘어오지 않은 상태에서 말로만 이 부분이 변경이 있다라는 식으로 전달 받을때는 당황스러웠는데, 손그림으로라도 그려서 주셨으면 좋겠다고 하니 AdobeXD로 빠르게 수정된 디자인을 받았다. 디자인하는 것을 옆에서 구경했는데, AdobeXD에서 아이콘을 리스트에 동일하게 추가하는데 스크롤만 내리니 아이콘이 간격대로 생성이 되었다. 포토샵은 어느정도 기본만 할 수 있는 수준이고, 이미지 내보내는 부분 정도만 액션을 추가한다든지 하는 식으로 활용하고 있어서 포토샵에도 그런 기능이 있는지는 모르겠지만 굉장히 신기했다.(업무 효율 올라가는 소리가…)굉장히 신기해서 찾아봤는데, 반복 그리드라는 작업이었다.오늘 업체 개발자와 커뮤니티를 하면서 느낀게 상대의 말이 이해가 안되면 많이 물어봐야하고, 상대방이 알아듣기 쉽도록 설명해야 된다는 거였다. 아무리 개발 용어라도, 어떤 의도에서 썼는지는 본인만 알 수 있었다. 그리고 나와 대화하는 사람이 이정도는 알고있을 것이다라는 예측은 하면 안된다는 것.그리고 동적으로 리스트를 생성하기를 원하셨고, 그부분에서 CSS가 안 먹기 때문에 CSS를 인라인으로 넣겠다고 하셔서 이부분에 대한 커뮤니케이션이 좀 어려웠는데, 결론은 내가 개발자님이 말씀하시는 데이터 형태에 맞춰 리스트가 동적으로 생성되는 코드를 짜보기로 했고, 마크업 개발 외주여서 이것까지 하게 될 줄은 몰랐지만 재미있는 작업이었다.개발자님이 말씀하신 배열이 어떤 구조인지 여쭤보고, for문 안에서 리스트 아이템에 데이터를 넣고 생성되도록 했는데, for문을 두번 돌리기 전에 filter 메소드를 통해 두번째 배열의 아이템이 첫번째 배열의 정보를 가지고 있는지를 먼저 체크하도록 해서 다음 for문을 돌릴때 대상에 두번째 배열에서 필터링 된 배열 정보를 넘겨줬다. 그래서 for문을 좀 더 덜 돌 수 있게 되었다.","categories":[{"name":"TIL","slug":"TIL","permalink":"http://chiabi.github.io/categories/TIL/"}],"tags":[{"name":"TIL","slug":"TIL","permalink":"http://chiabi.github.io/tags/TIL/"}]},{"title":"TIL","slug":"TIL","date":"2018-07-26T14:58:25.000Z","updated":"2018-07-26T16:04:47.005Z","comments":true,"path":"2018/07/26/TIL/","link":"","permalink":"http://chiabi.github.io/2018/07/26/TIL/","excerpt":"","text":"오늘 한 일Sass 스터디Sass는 계속 쓰고 있었지만, 스터디를 준비하면서 다시 공부했다. Dart Sass가 나온 배경이라든지 Sass blog에 올라온 글도 읽어보고 처음부터 시작한다 생각하고 Sass를 사용하기 위한 환경 설정도 다시 해보니, 다른 방법이 있거나 제대로 모르고 있던 부분도 알 수 있었다.특히 설치에서 애를 먹었는데, 내가 현재 사용하고 있는 node 버전은 8이었고, Sass는 아직 node 8버전에서 공식적으로 지원되는 것이 아니어서 발생한 문제였다. 그래서 nvm을 통해 설치된 node 버전 중 6.10.0으로 변경하니 발생했던 오류가 사라졌다.가볍게 쓰려고 사용하고 있던 VSCode 익스텐션인 Live Sass Compiler는 생각보다 훨씬 좋았다. Autoprefix를 같이 쓰려고 gulp-sass 사용할 때 설치하고 설정해주고 했었는데, Live Sass Compiler는 이를 지원한다.다른 사람에게 설명해주기 위한 준비과정 자체가 많은 도움이 되는 것 같다. 내가 무엇을 알고, 무엇을 모르고 있는지가 좀 더 명확해진다. 오늘 Sass 문법까지 다루고 싶었는데, 환경 설정하면서 package.json부터 설명을 해야 되어서 생각보다 시간이 훌쩍 지나가버렸다. 대충 Sass를 사용하면 어떤 점이 좋을지 왜 Sass를 사용하는지 위주로 대화를 했고, 문법 관련해서는 생소한 &amp;같은 부모참조 선택자나 Sass와 SCSS의 차이, BEM 방법론을 사용할 때 Sass 활용 방법 (중첩이나 부모참조 선택자)위주로 설명했다.함수나 리스트, 맵과 반복문을 사용해 어떤 것을 할 수 있을지 등도 보여주고 싶었는데, 시간이 부족해서 아쉬웠다.Sass는 내가 스크립트 언어를 익히는데 많은 도움을 준 언어라 굉장히 애착이 간다. 그리고 그걸 오늘 다시 공부해보면서 느꼈다. CSS로는 할 수 없는 정말 멋진 기능이 많은데 오늘 다 못해서 아쉽고, 나중에 또 시간을 내야겠다.","categories":[{"name":"TIL","slug":"TIL","permalink":"http://chiabi.github.io/categories/TIL/"}],"tags":[{"name":"TIL","slug":"TIL","permalink":"http://chiabi.github.io/tags/TIL/"}]},{"title":"TIL","slug":"TIL","date":"2018-07-25T14:59:38.000Z","updated":"2018-07-25T16:42:26.366Z","comments":true,"path":"2018/07/25/TIL/","link":"","permalink":"http://chiabi.github.io/2018/07/25/TIL/","excerpt":"","text":"오늘 한 일TIL 레포지토리 정리깃헙의 TIL 레포지토리의 구조를 좀 수정했다. 프론트엔드 개발 스쿨과정에서 WEEK_N 디렉토리로 정리했던 파일들은 [FDS]fds-9로 옮겼고, 앞으로 카테고리 별로 공부한 내용을 관리하려 한다.깃헙의 project를 이용해서 할 일을 관리해보려고 하는데, 풀리퀘 말고 이슈와 커밋을 연결해서 깃헙 이슈에 기록을 남기는 방법을 찾아봤는데, 좀 더 찾아봐야겠지만 커밋으로 이슈를 닫는 기능은 있었다. Closing issues using keywords 리덕스 공부리덕스 문서 원문과 번역본을 같이 보면서 공부하고 있다. 일단 기초 부분을 한번 읽어보면서 따라 치는 식으로 하고 있는데,에러가 발생해서 확인해봐야 한다. 국비 과정때 같이 공부했던 동기와 스터디를 하기로 했는데, 내일 Sass를 주제로 진행할 예정이다. 최근에 외주하면서도 사용하기는 했는데, 전 회사에서 했던 것처럼 내가 발표하는 형식으로 진행해야 해서 다시 한번 정리해야겠다. 원래는 낮에 리덕스 공부하고 나서 준비하려고 했는데, 생각보다 리덕스 개념이 잘 이해가 안가서 시간을 많이 잡아먹었다. 비록 에러를 아직 해결하지 못했지만, 예제를 통해 기초파트의 한 사이클을 도니까 좀 이해가 되는 것 같다. 내일은 이 에러를 해결하고 심화부분을 보면서 파이널 프로젝트로 했던 SEEMVA를 수정해봐야겠다.","categories":[{"name":"TIL","slug":"TIL","permalink":"http://chiabi.github.io/categories/TIL/"}],"tags":[{"name":"TIL","slug":"TIL","permalink":"http://chiabi.github.io/tags/TIL/"}]},{"title":"Self Dividing Numbers","slug":"SelfDividingNumbers","date":"2018-07-25T14:57:22.000Z","updated":"2018-07-25T17:17:09.442Z","comments":true,"path":"2018/07/25/SelfDividingNumbers/","link":"","permalink":"http://chiabi.github.io/2018/07/25/SelfDividingNumbers/","excerpt":"","text":"leetcode 문제링크 A self-dividing number is a number that is divisible by every digit it contains.For example, 128 is a self-dividing number because 128 % 1 == 0, 128 % 2 == 0, and 128 % 8 == 0.Also, a self-dividing number is not allowed to contain the digit zero.Given a lower and upper number bound, output a list of every possible self dividing number, including the bounds if possible. Example 1: Input: left = 1, right = 22 Output: [1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12, 15, 22]Note: The boundaries of each input argument are 1 &lt;= left &lt;= right &lt;= 10000. 나의 풀이숫자를 문자열로 만들어 쪼개서 나누어떨어지면 push로 배열에 추가하는 방법12345678// 64msvar selfDividingNumbers = function(left, right) &#123; const result = []; for (let i = left; i &lt;= right; i++) &#123; if(i.toString().split('').every(item =&gt; i % parseInt(item) === 0)) result.push(i); &#125; return result&#125;; 그런데 0이 포함되면 self-dividing number가 아니므로 이렇게 추가해줘도 될 것 같다.12345678/// 68msvar selfDividingNumbers = function(left, right) &#123; const result = []; for (let i = left; i &lt;= right; i++) &#123; if(i % 10 !== 0 &amp;&amp; i.toString().split('').every(item =&gt; i % parseInt(item) === 0)) result.push(i); &#125; return result&#125;; 123456789101112131415var selfDividingNumbers = function(left, right) &#123; const result = []; for (let i = left; i &lt;= right; i++) &#123; const numbers = i.toString().split(''); let divide = true; for (const n of numbers) &#123; if (i % n !== 0) &#123; divide = false; break; &#125; &#125; if(divide) result.push(i) &#125; return result&#125;;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://chiabi.github.io/categories/Algorithm/"}],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://chiabi.github.io/tags/algorithm/"},{"name":"leetcode","slug":"leetcode","permalink":"http://chiabi.github.io/tags/leetcode/"}]},{"title":"TIL","slug":"TIL","date":"2018-07-24T11:59:40.000Z","updated":"2018-07-24T16:21:38.719Z","comments":true,"path":"2018/07/24/TIL/","link":"","permalink":"http://chiabi.github.io/2018/07/24/TIL/","excerpt":"","text":"오늘 한 일퍼블리싱 외주 완료작업 기한은 27일까지이긴 하지만 웹에이전시에서 일할 당시를 생각하면, 개발로 넘어가면 수많은 변수가 생기기 때문에 개발을 붙일 수 있는 시간에 여유를 드려야 할 것 같아서 일찍 완료해 넘겼다. 학원으로 이동 중에 연락이 와서, 이미지가 보이지 않고 이벤트들이 하나도 발생하지 않는다고 확인 요청이 왔다. 별다른 개발 환경세팅이 필요한지 여쭤보시기에 혹시 서버에 올려서 테스트하거나 아니면 라이브 서버를 통해 확인하고 계시냐고 여쭤봤는데, 개발자분이 그렇다고 하시기는 했는데, 그냥 로컬에서 파일을 열어 확인해보셨던 것 같다. 그래서 절대경로로 된 path를 읽지 못하는 거였다. 나는 작업할 때 vscode의 라이브 서버 확장프로그램을 사용해서 이상이 없었지만 상대경로로 다시 수정해서 넘겨드렸다. 모의 면접학원에서 진행하는 마지막 모의 면접을 봤다. 기술 면접은 아니고 자기소개서를 바탕으로 하는 인성 면접이었는데, 1차로 봤던 모의 면접에 비해 많이 나아진 것 같다. 프론트엔드 개발에 관련된 프로젝트를 해보고 기업조사도 하면서 좀 더 내가 어떤 방향으로 나아가야할 지 목표가 확실해지고, 나 자신에 대해 더 알게 되어서 말할 거리가 많이 생긴 것 같다. 리덕스 복습외주로 조금 소홀해진 복습에 다시 열중해야겠다. 일단 가장 하고 싶었던 context API로 만든 파이널 프로젝트를 리덕스를 이용해 수정하는 것을 하기 위해 리덕스를 복습하고 있다. 튜토리얼을 따라서 하는데, 특강때 했던 내용이 하나씩 다시 생각나고 있다. Git, github 특강fork한 저장소의 최신 변경사항을 받아오는 방법에 대한 내용이 주였고, 관련해서 실습도 진행되었다. git stash에 대해 좀 더 찾아보자. 날이 너무 더워서 많이 이동하는 날은 기력이 쭉 빠진다. 얼른 시원해졌으면 좋겠다.","categories":[{"name":"TIL","slug":"TIL","permalink":"http://chiabi.github.io/categories/TIL/"}],"tags":[{"name":"TIL","slug":"TIL","permalink":"http://chiabi.github.io/tags/TIL/"}]},{"title":"MaxIncreasetoKeepCitySkyline","slug":"MaxIncreasetoKeepCitySkyline","date":"2018-07-24T11:55:37.000Z","updated":"2018-07-25T16:42:48.719Z","comments":true,"path":"2018/07/24/MaxIncreasetoKeepCitySkyline/","link":"","permalink":"http://chiabi.github.io/2018/07/24/MaxIncreasetoKeepCitySkyline/","excerpt":"","text":"leetcode 문제링크 In a 2 dimensional array grid, each value grid[i][j] represents the height of a building located there. We are allowed to increase the height of any number of buildings, by any amount (the amounts can be different for different buildings). Height 0 is considered to be a building as well. At the end, the “skyline” when viewed from all four directions of the grid, i.e. top, bottom, left, and right, must be the same as the skyline of the original grid. A city’s skyline is the outer contour of the rectangles formed by all the buildings when viewed from a distance. See the following example. What is the maximum total sum that the height of the buildings can be increased? Example: Input: grid = [[3,0,8,4],[2,4,5,7],[9,2,6,3],[0,3,1,0]] Output: 35Explanation: The grid is:1234[ [3, 0, 8, 4], [2, 4, 5, 7], [9, 2, 6, 3], [0, 3, 1, 0] ] The skyline viewed from top or bottom is: [9, 4, 8, 7] The skyline viewed from left or right is: [8, 7, 9, 3] The grid after increasing the height of buildings without affecting skylines is: 1234gridNew = [ [8, 4, 8, 7], [7, 4, 7, 7], [9, 4, 8, 7], [3, 3, 3, 3] ] Notes: 1 &lt; grid.length = grid[0].length &lt;= 50. All heights grid[i][j] are in the range [0, 100]. All buildings in grid[i][j] occupy the entire grid cell: that is, they are a 1 x 1 x grid[i][j] rectangular prism. 나의 풀이배열을 두번이나 탐색해야해서 좋은 방법이 아닌 것 같아서 좀 괴로운데, 가장 단순하게 생각할 수 있는 방법인 것 같다. 먼저, 위/아래의 스카이라인과 좌/우의 스카이라인을 구해두고, reduce메소드를 사용해 다시 배열을 탐색하면서, 해당 좌표의 스카이라인 중 작은 값을 구하고 원래의 값을 뺀 값을 누적으로 더해주는 방법으로 풀어봤다. 123456789101112131415161718// 64 msvar maxIncreaseKeepingSkyline = function(grid) &#123; const upDown = []; const side = []; for (let i = 0, l = grid.length; i &lt; l; i++) &#123; side.push(Math.max(...grid[i])); const arr = []; for (let j = 0; j &lt; l; j++) &#123; arr.push(grid[j][i]); &#125; upDown.push(Math.max(...arr)); &#125; return grid.reduce((acc, row, index) =&gt; &#123; return acc + row.reduce((a, col, i) =&gt; &#123; return a + (Math.min(side[index], upDown[i]) - col); &#125;, 0); &#125;, 0)&#125;; 코드 길이는 줄였는데, 더 느려졌다. 6번째 줄에 const cMax = Math.max(...arr.map((item) =&gt; item[i])); 이부분이 원인인 것 같다.12345678910// 96msvar maxIncreaseKeepingSkyline = function(grid) &#123; return grid.reduce((acc, row, index, arr) =&gt; &#123; const rMax = Math.max(...row); return acc + row.reduce((a, col, i) =&gt; &#123; const cMax = Math.max(...arr.map((item) =&gt; item[i])); return a + (Math.min(rMax, cMax) - col) &#125;, 0) &#125;, 0)&#125;;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://chiabi.github.io/categories/Algorithm/"}],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://chiabi.github.io/tags/algorithm/"},{"name":"leetcode","slug":"leetcode","permalink":"http://chiabi.github.io/tags/leetcode/"}]},{"title":"TIL","slug":"TIL","date":"2018-07-23T14:10:16.000Z","updated":"2018-07-24T11:55:00.126Z","comments":true,"path":"2018/07/23/TIL/","link":"","permalink":"http://chiabi.github.io/2018/07/23/TIL/","excerpt":"","text":"오늘 한 일퍼블리싱 외주(80% 진행)디자인 시안의 폰트 사이즈가 대부분 10px이하다. 어떤 버튼은 폰트 사이즈가 7px이다. 아이패드에서는 그나마 좀 잘 보이는데, 작업하는 내가 괴로울 정도로 노트북에서는 잘 안보인다.(내가 눈이 나쁜건가…)쇼핑몰 퍼블리싱할 때 받았던 디자인에서는 대부분 기본적인 폰트 사이즈는 12px 혹은 14px이고 제일 작은 폰트 사이즈가 10px이었다. 그리고 그렇게 해야 가독성이 좋았는데, 아이패드나 브라우저에서 화면을 확대하는 방법이 있기 때문에 그렇게 하는 걸까. 웹디자인을 위한 타이포그라피 10가지 팁 반응형 웹 디자인에서 글줄의 길이와 글자 크기 균형 잡기 MDN - font-size-adjust 디자인에 range 슬라이더가 있어서 찾아봤는데 rangeslider.js가 제일 복잡한 기능없이 간단하게 사용하기 좋았다. rangeslider.js 디자인 시안을 어떤 파일로 전달해주면 되냐고해서 포토샵이나 일러면 좋을 것 같다고 했더니 보낸 파일이 전혀 레이어가 분할되어 있지 않았다. sketch로 작업했구나 싶어서 차라리 sketch 파일로 보내달라고 했는데, 재플린으로 공유해달랄 걸 그랬나보다. 하지만 덕분에 윈도우에서 sketch파일을 보는 방법을 찾아보다가 .sketch 파일을 지원하는 Windows app인 lunacy라는 걸 찾았다.(무료다!!)그리고 시안 수정은 또 클라이언트 업체의 상주 디자이너가 하는데(시안 자체는 외주), sketch는 안쓰는지 Adobe XD 파일을 보내줬다.포토샵으로만 시안 받아서 퍼블리싱 해봤는데 덕분에 이런 저런 툴을 다양하게 사용해보고 있다. lunacy Adobe XD 알고리즘 문제 풀이문제가 조금 간단하고 장고걸스 튜토리얼에서 봤던 정도로도 풀 수 있을 것 같아서 파이썬으로도 풀어봤다.range나 len 함수에 대해 찾다가 파이썬 문법을 공부하는데 도움이 될 것 같은 사이트를 찾았다. 점프 투 파이썬 내일까지면 퍼블리싱 외주 작업은 끝날 것 같다. 그러면 다시 파이널 프로젝트에 집중해서 Context API를 썼던 부분을 리덕스로 변경하는 작업에 착수해야겠다.","categories":[{"name":"TIL","slug":"TIL","permalink":"http://chiabi.github.io/categories/TIL/"}],"tags":[{"name":"TIL","slug":"TIL","permalink":"http://chiabi.github.io/tags/TIL/"}]},{"title":"peakIndexInMountainArray","slug":"peakIndexInMountainArray","date":"2018-07-23T13:10:22.000Z","updated":"2018-08-06T03:01:39.028Z","comments":true,"path":"2018/07/23/peakIndexInMountainArray/","link":"","permalink":"http://chiabi.github.io/2018/07/23/peakIndexInMountainArray/","excerpt":"","text":"leetcode 문제링크 Let’s call an array A a mountain if the following properties hold: A.length &gt;= 3There exists some 0 &lt; i &lt; A.length - 1 such that A[0] &lt; A[1] &lt; ... A[i-1] &lt; A[i] &gt; A[i+1] &gt; ... &gt; A[A.length - 1]Given an array that is definitely a mountain, return any i such that A[0] &lt; A[1] &lt; ... A[i-1] &lt; A[i] &gt; A[i+1] &gt; ... &gt; A[A.length - 1]. Example 1: Input: [0,1,0] Output: 1 Example 2: Input: [0,2,1,0] Output: 1 Note: 3 &lt;= A.length &lt;= 10000 0 &lt;= A[i] &lt;= 10^6 A is a mountain, as defined above. 나의 풀이JavaScript배열에서 조건에 일치하는 첫번째 인덱스를 찾아주는 findIndex() 메소드를 사용했다.12345678// 56 msvar peakIndexInMountainArray = function(A) &#123; return A.findIndex((item, index, arr) =&gt; &#123; if(index &lt; arr.length - 1) &#123; return item &gt; arr[index + 1]; &#125; &#125;)&#125;; A 배열은 산이라고 했으니까 Math.max의 인덱스를 구하는 방법을 사용했다.12345// 56msvar peakIndexInMountainArray = function(A) &#123; const max = Math.max(...A); return A.findIndex(item =&gt; item === max);&#125;; 근데 위의 방법은 indexOf로 더 짧게 풀 수 있다.1234// 56msvar peakIndexInMountainArray = function(A) &#123; return A.indexOf(Math.max(...A))&#125;; Python문제가 크게 어렵지 않아서 파이썬으로도 풀어봤다.123456789101112131415# 40msclass Solution: def peakIndexInMountainArray(self, A): \"\"\" :type A: List[int] :rtype: int \"\"\" number = 0 before = 0 for i in A: if number &gt; 1 and i &lt; before: return number - 1 else: number = number + 1 before = i 다른 사람 풀이Python파이썬의 for문은 자바스크립트의 for of처럼 i라는 변수에 리스트의 요소가 대입되니까 인덱스는 어떻게 구하지라고 생각했는데,다음과 같이 range함수와 len함수를 이용하는 방법이 있었다.123456789class Solution: def peakIndexInMountainArray(self, A): \"\"\" :type A: List[int] :rtype: int \"\"\" for i in range(1, len(A)-1): if A[i] &gt; A[i-1] and A[i]&gt; A[i+1]: return i range(): 숫자 리스트를 자동으로 만들어 주는 함수 len(): 리스트 내 요소의 개수를 돌려주는 함수","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://chiabi.github.io/categories/Algorithm/"}],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://chiabi.github.io/tags/algorithm/"},{"name":"leetcode","slug":"leetcode","permalink":"http://chiabi.github.io/tags/leetcode/"}]},{"title":"7월 3주차 주간회고","slug":"retrospective","date":"2018-07-22T13:41:12.000Z","updated":"2018-07-22T17:38:57.041Z","comments":true,"path":"2018/07/22/retrospective/","link":"","permalink":"http://chiabi.github.io/2018/07/22/retrospective/","excerpt":"","text":"1. 퍼블리싱 외주와 커뮤니케이션지난주 학원에서 3일간 진행했던 해커톤에서의 만남을 계기로 한 사이트의 퍼블리싱을 맡게 되었다. 남은 공부와 구직(기업조사라든지, 포트폴리오 사이트라든지)에 전념해야 할 것 같아서 고민이 되었는데, 사이트 업종 자체가 내가 흥미를 느끼고 있던 분야의 것이고, 다른 사람의 디자인을 그대로 구현해보는 것은 오랜만이라 흥미가 생겨서 계약하게 되었다.업체 대표님의 신뢰는 중개하는 분에 대한 신뢰인 것 같기도 하고 해커톤 산출물만으로 괜찮다고 생각했던 건지, 별다른 포트폴리오를 보여달라고 하지 않아서 조금 당황스러웠다. 그래도 상주해서 하는 작업이 아니라서 그런지 조금 우려는 하시는 것 같아서 작업 기간 동안 영업 종료시간(6시)에 작업 현황을 보내드리고 있다. 웹에이전시에서 일할 당시에는 직접 클라이언트와 커뮤니케이션 할 일이 없었고, 직원끼리는(다른 팀이더라도) 조금 전문적인 용어를 써도 어느 정도 이해할 수 있는 범위여서 커뮤니케이션에 지장이 없었는데, 이번에 직접 업체 대표님과 대화를 해보니 나로서는 크게 어려운 말이 아니었다고 생각했어도 상대방에게는 어렵게 느껴진다는 걸 알았다. (조금이라도 웹 개발 쪽 언어라면 그게 ‘HTML, CSS’ 혹은 ‘퍼블리싱’이더라도 개발자가 아닌 이상은 듣는 입장에서 식은땀을 흘리게 되더라…)첫 미팅은 월요일이었는데, 화요일에 학원에서 진행했던 특강에서 정원희 개발자님이 하신 말씀이 그다음 커뮤니케이션에 많은 도움이 되었다. 정원희 개발자님이 하신 말씀 중에 커뮤니케이션을 할 때 서버라는 용어조차 모르는 사람도 있으므로 전문적인 용어를 쓰지 않고 모두 쉬운 말로 풀어서 한다고 하셨다. 생각해보니 상대방이 어떤 사람이냐에 상관없이 전문적인 용어를 마구 써서 대화를 풀어나가려는 사람은 실질적으로 내재한 지식의 총량이 어느 정도이건 간에 커뮤니케이션 면에서는 이기적이고 무능한 사람인 것 같다. 그리고 사실 어려운 것을 쉽게 풀어 설명하는 게 더 어려운 일이다.특강을 듣고나니 과연 나는 상대방을 배려한 대화를 했었는지 반성하게 되었다. 2. 정원희 개발자님 특강화요일(7월 17일), 패스트캠퍼스에서 진행한 정원희 개발자님 특강을 들었다. (정원희 개발자님은 트레바리의 CTO이자 개발자로 일하고 계신다.)‘왜 스타트업 개발자가 되었는 지’와 ‘스타트업에서 살아남는(사랑받는) 개발자가 되기 위해 무엇을 했는지’에 대해서 강의를 해주셨다.중소기업이며, 설립한 지 10년도 넘은 웹에이전시에서만 일해봐서, 자사 서비스를 제공하는 스타트업을 도전하고 싶었는데, 내가 스타트업을 가려고 한다면 어떤 고민을 해야할 지 알 수 있는 강의였다.정원희 개발자님이 욕심에 비해 의지가 약한 사람이기 때문에 강제로 개발하는 환경에 본인을 던지기 위해 최적인 곳으로 회사를 선택하셨다는데, 그 부분이 많이 공감이 되었고, 취업을 해야할지 부족한 나를 채우는 시간을 가져야할지 어느 것이 더 좋은 선택인지 고민하고 있는 내게 방향을 제시해주었다.실패 후 다시 도전은 또 다른 가산점이라는 말씀도 많이 도움이 되었다. 구직을 하려다보면 자격요건에 요구되는 다양한 경험과 경력 사항들이 있다. 이것을 다 채우고 완벽한 지원자가 되려면 나에게 취업은 요원한 일이 될 것이다. 당장 모든 것이 완벽하지 않더라도 어느 정도 준비가 되어있다면 부딪치면서 채워나가야 될 것 같다. 그 부딪치는 과정에서도 나는 많은 것을 배울 수 있을 것이다. 3. 장고걸스 워크샵장고걸스 워크샵 후기는 나중에 또 시간을 들여 작성을 하려한다. 새로운 것을 배우는 것, 경험해보는 것은 즐거운 일이다. 굉장히 유익한 경험이 었고, 단순히 ‘장고라는 파이썬 기반 웹 프레임워크를 경험해 본다’ 이상의 경험이었다.장고걸스 워크샵을 신청한 계기는 ‘잘 만들어진 튜토리얼을 제공한다해도 누구의 도움도 없이 생소한 언어와 생소한 기술을 사용해 보는 것은 굉장히 오랜 시간이 걸릴 수 있으니 워크샵을 통해 코치들의 도움을 받아 한 사이클을 빠르게 경험해보자’였다.프론트엔드 개발 스쿨 전에 이 튜토리얼에 도전해보려 했는데, 마치 ‘이정도는 다 아시죠?’라는 느낌을 받았고, 모르는 것을 일일이 찾아보다보니 엄청난 시간이 소요되었다. 나는 어떠한 거대한 장벽을 바라보는 느낌이었다.장고걸스 워크샵에서는 어떠한 바보같은 질문도 허용된다는 점이 가장 좋았다. 왜냐하면 초보 여성 개발자 혹은 개발에 입문하려는 여성들을 위한 모임이니까!워크샵 동안 튜토리얼을 따라가는 데는 처음에 봤을때보다 큰 어려움이 없었다. 아마도 프론트엔드 개발 스쿨을 통해 개발에 대해 더 아는 것이 생겼기 때문이기도 할 거고, 가장 어려운 개발 환경 설정의 대부분이 이미 되어있었기 때문일 것이다.(git이라든지 에디터라든지) 블로그 만들기는 생각보다 수월하게 진행되었지만 가상환경이라거나, 파이썬 문법, 장고의 기능 같은 점을 코치님(이재열 개발자님)께 많이 질문했던 것 같다. 코치님도 어려운 부분을 쉽게 설명해주시려 고심해서 말을 골라가며 친절히 설명해주셨다.밋업 같은 것은 아직 아는 사람이 없고, 개발 경험이 많지 않아서 과연 잘 어울릴 수 있을까 부담스러워서 도전하지 못하고 있는데, 그런면에서 장고걸스 워크샵은 입문자가 가장 접근하기 좋은 개발 커뮤니티인 것 같다.프론트엔드 개발과 함께 파이썬, 장고도 꾸준히 공부해서 다음에는 코치로 참여하는 것을 목표로 해야겠다. 이번주에 일일 회고를 제대로 하지 못했다. 지금 목표는 일일 회고 / 일일 알고리즘 문제 풀이 / 일일 커밋이다. 어려운 일이 아닌 것 같은데도 온전히 내가 만들어서 하는 일만 있는 게 아닌 경우는(외주를 맡거나 회사를 다니게 되면) 또 쉽지만은 않은 일이 되어버리는 것 같다.제일 중요한 것은 결과가 나만의 책임이 아닌 일에 집중하는 것이지만, 그 사이에서도 시간 관리를 잘해서 내 개인적인 목표도 성취할 수 있도록 조율해야 겠다.","categories":[{"name":"회고","slug":"회고","permalink":"http://chiabi.github.io/categories/회고/"}],"tags":[{"name":"회고","slug":"회고","permalink":"http://chiabi.github.io/tags/회고/"}]},{"title":"UniqueMorseCodeWords","slug":"UniqueMorseCodeWords","date":"2018-07-19T02:16:33.000Z","updated":"2018-07-24T15:50:27.415Z","comments":true,"path":"2018/07/19/UniqueMorseCodeWords/","link":"","permalink":"http://chiabi.github.io/2018/07/19/UniqueMorseCodeWords/","excerpt":"","text":"leetcode 문제링크 International Morse Code defines a standard encoding where each letter is mapped to a series of dots and dashes, as follows: “a” maps to “.-“, “b” maps to “-…”, “c” maps to “-.-.”, and so on. For convenience, the full table for the 26 letters of the English alphabet is given below: [&quot;.-&quot;,&quot;-...&quot;,&quot;-.-.&quot;,&quot;-..&quot;,&quot;.&quot;,&quot;..-.&quot;,&quot;--.&quot;,&quot;....&quot;,&quot;..&quot;,&quot;.---&quot;,&quot;-.-&quot;,&quot;.-..&quot;,&quot;--&quot;,&quot;-.&quot;,&quot;---&quot;,&quot;.--.&quot;,&quot;--.-&quot;,&quot;.-.&quot;,&quot;...&quot;,&quot;-&quot;,&quot;..-&quot;,&quot;...-&quot;,&quot;.--&quot;,&quot;-..-&quot;,&quot;-.--&quot;,&quot;--..&quot;] Now, given a list of words, each word can be written as a concatenation of the Morse code of each letter. For example, “cab” can be written as “-.-.-….-“, (which is the concatenation “-.-.” + “-…” + “.-“). We’ll call such a concatenation, the transformation of a word. Return the number of different transformations among all words we have. Example: Input: words = [“gin”, “zen”, “gig”, “msg”] Output: 2 Explanation: The transformation of each word is:“gin” -&gt; “–…-.”“zen” -&gt; “–…-.”“gig” -&gt; “–…–.”“msg” -&gt; “–…–.” There are 2 different transformations, “–…-.” and “–…–.”. Note: The length of words will be at most 100. Each words[i] will have length in range [1, 12]. words[i] will only consist of lowercase letters. 나의 풀이유니크한 값을 찾으면 다른 수의 경우도 나올 것 같아서 Set을 이용해보았다.123456789101112131415// 64msconst morse = [\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"]; const alphabet = 'abcdefghijklmnopqrstuvwxyz';var uniqueMorseRepresentations = function(words) &#123; const morseWords = new Set(); for (const word of words) &#123; let newStr = ''; for(const i of word) &#123; newStr += morse[alphabet.indexOf(i)]; &#125; morseWords.add(newStr) &#125; return morseWords.size;&#125;;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://chiabi.github.io/categories/Algorithm/"}],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://chiabi.github.io/tags/algorithm/"},{"name":"leetcode","slug":"leetcode","permalink":"http://chiabi.github.io/tags/leetcode/"}]},{"title":"TIL","slug":"TIL","date":"2018-07-18T02:14:25.000Z","updated":"2018-07-23T14:10:38.180Z","comments":true,"path":"2018/07/18/TIL/","link":"","permalink":"http://chiabi.github.io/2018/07/18/TIL/","excerpt":"","text":"오늘 한 일Javascript30 14차 JavaScript References VS Copying 원시 타입과 찹조타입의 복사에 관한 차이와 얕은복사, 깊은 복사에 대한 내용이었다. 다음은 배열을 복사하는 방법이다.(단, 얕은 복사)123456const cats = ['Syami', 'Jojo', 'Loki', 'Kkonnim'];const team1 = cats.slice();const team2 = [].concat(cats);const team3 = [...cats]const team4 = Array.from(cats) Array.from() 메서드는 배열의 형태를 갖거나 순회 가능한 객체로부터 얕게 복사한 Array 객체를 만듭니다. 다음은 객체를 복사하는 방법이다.(단, 얕은 복사)123456const cat = &#123; name: 'Syami', age: 10&#125;const cat2 = Object.assign(&#123;&#125;, cat, &#123; kind: 'korean shot', age: 11&#125;) 이러한 복사는 1 레벨의 깊이만 복사가 가능하다. 배열 안 배열 혹은 객체 안 배열 등등의 중첩되어 여러 레벨의 깊이가 생긴 객체(혹은 배열)을 복사하는 방법은 깊은 복사라고 하며 강의에서는 그 방법 중 하나를 소개해 줬는데 다음과 같다.123456789const cat = &#123; name: 'Syami', age: 10, family: &#123; brother: ['Jojo', 'Loki'], sister: ['Kkonnim', 'Samsun'] &#125;&#125;const cat2 = JSON.parse(JSON.stringify(cat)) 그러나 이 방법은 성능상 매우 안 좋고, 직렬화 할 수 없는 속성들은(prototype이라든가) 날라가 버리기 때문에 좋은 방법은 아니라고 한다. 파이널 프로젝트 2차 준비서버를 GraphQL로 하자는 얘기가 나와서 다음의 영상들을 보게 되었는데, 많이 도움이 되었다. 1강 GraphQL Server 만들기 Hello, GraphQL! Graph QL 도입으로 얻었던 효과 - 조민환 그런데 프로젝트에 기획했지만 아직 구현되지 못한 부족한 부분이 많고, 처음부터 Apollo client를 쓰려니 잘 이해되지 않는 부분이 많아서 먼저 리덕스로 변경하는 것부터 처리하는 게 좋을 것 같아 리덕스를 먼저 해보기로 했다.","categories":[{"name":"TIL","slug":"TIL","permalink":"http://chiabi.github.io/categories/TIL/"}],"tags":[{"name":"TIL","slug":"TIL","permalink":"http://chiabi.github.io/tags/TIL/"}]},{"title":"Judge Route Circle","slug":"JudgeRouteCircle","date":"2018-07-17T14:40:55.000Z","updated":"2018-07-24T15:51:00.593Z","comments":true,"path":"2018/07/17/JudgeRouteCircle/","link":"","permalink":"http://chiabi.github.io/2018/07/17/JudgeRouteCircle/","excerpt":"","text":"leetcode 문제링크 Initially, there is a Robot at position (0, 0). Given a sequence of its moves, judge if this robot makes a circle, which means it moves back to the original place. The move sequence is represented by a string. And each move is represent by a character. The valid robot moves are R (Right), L (Left), U (Up) and D (down). The output should be true or false representing whether the robot makes a circle. Example 1: Input: “UD” Output: true Example 2: Input: “LL” Output: false 나의 풀이문제 자체를 이해하기가 좀 어려웠다. 괜히 Circle이라 그래서 왜 원이 되지?라고 생각했는데, 그림을 그려보면 이해하기 쉬웠다. 예를들면 “RLUURDDLU”를 좌표 (0, 0)에서 시작한다고 생각해서 방향따라 그려보면 결국 다시 (0, 0)의 위치로 오게 된다. 이 경우 로봇이 원을 만든다고 가정하여 true를 반환하면 된다. 그래서 “LDRRLRUULR”의 경우 그려보면 (0, 0)의 위치로 돌아오지 않기 때문에 false를 반환하면 된다. 정규식을 이용했다. R과 L의 수와 U와 D의 수가 같으면 원 위치로 되돌아갔다고 할 수 있으니까 다음과 같이 접근해서 풀어보았다.|| []이 부분은 마지막에 length로 구하고 싶은데 match 메소드가 정규식에 부합하는 문자열이 있으면 배열 형태로 반환하지만 없을 경우 null로 반환하기 때문에 정규식에 일치하는 문자가 없을 경우는 빈배열이 담기도록 하기 위해 추가했다.12345678// 68msvar judgeCircle = function(moves) &#123; const R = moves.match(/R/g) || []; const L = moves.match(/L/g) || []; const U = moves.match(/U/g) || []; const D = moves.match(/D/g) || []; return R.length === L.length &amp;&amp; U.length === D.length&#125;; 이번에는 for문을 통해 문자열을 하나씩 탐색해서 x와 y의 값에 변화를 주는 방법을 사용했다. 오른쪽으로 이동하면 x좌표가 1추가되고 왼쪽으로 이동하면 x좌표가 1 감소하는 것이라 모든 문자열을 탐색한 뒤에 x와 y의 좌표가 다시 0이 되었는지 확인한다.123456789101112// 72msvar judgeCircle = function(moves) &#123; let x = 0; let y = 0; for (const i of moves) &#123; i === 'R' ? x++ : i === 'L' ? x-- : i === 'U' ? y-- : i === 'D' &amp;&amp; y++; &#125; return x === 0 &amp;&amp; y === 0&#125;; 같은 접근법인데 reduce 메소드를 이용해 본 방법1234567// 72msvar judgeCircle = function(moves) &#123; const arr = moves.split(''); const hor = arr.reduce((acc, item) =&gt; acc + (item === 'R' ? 1 : item === 'L' ? -1 : 0), 0); const ver = arr.reduce((acc, item) =&gt; acc + (item === 'U' ? 1 : item === 'D' ? -1 : 0), 0); return !(hor + ver)&#125;; 다른 사람 풀이같은 접근법인데 60ms이길래 환경이 달라서 그런 것 같아서 내가 다시 넣고 돌려보니 72ms가 걸렸다. 각 변수로 x, y를 넣는 대신 배열로 두고 switch 문을 사용한 방법이다.12345678910111213141516171819202122232425// 72msvar judgeCircle = function(moves) &#123; var origin = [0,0] for(var i = 0; i &lt; moves.length; i++)&#123; switch(moves[i])&#123; case 'U': origin[0]++ break case 'D': origin[0]-- break case 'L': origin[1]-- break case 'R': origin[1]++ break &#125; &#125; if(origin[0] == 0 &amp;&amp; origin[1] == 0)&#123; return true &#125;else&#123; return false &#125;&#125;; 문제의 좋아요와 싫어요 수가 거의 비슷해서 왜 인가했는데, 문제 자체가 이해가 어려워서였던 것 같다. 괜히 원을 만든다는 가정이 문제를 이해하기 어렵게 했다. 근데 문제 자체를 이해하고 나니 풀이는 재미있었다.특히 match메소드를 이용해서 null이 나오는데 배열의 length 프로퍼티로 비교하려고 하려면 어떻게 처리해야할까 고민했는데, || 논리 연산자를 이용해 match 메소드에서 null이 나오면 변수에 빈배열이 대입되도록 처리했다. 두번째 풀이의 삼항연산자에 쓴 것과 같이 &amp;&amp;와 ||같은 논리 연산자의 특성을 활용해보니 코드가 굉장히 깔끔해보여서 기분이 좋았다.","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://chiabi.github.io/categories/Algorithm/"}],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://chiabi.github.io/tags/algorithm/"},{"name":"leetcode","slug":"leetcode","permalink":"http://chiabi.github.io/tags/leetcode/"}]},{"title":"Hamming Distance","slug":"HammingDistance","date":"2018-07-16T02:07:15.000Z","updated":"2018-07-17T17:08:03.347Z","comments":true,"path":"2018/07/16/HammingDistance/","link":"","permalink":"http://chiabi.github.io/2018/07/16/HammingDistance/","excerpt":"","text":"leetcode 문제링크 The Hamming distance between two integers is the number of positions at which the corresponding bits are different. Given two integers x and y, calculate the Hamming distance. Note: 0 ≤ x, y &lt; 231. Example: Input: x = 1, y = 4 Output: 2 Explanation:1231 (0 0 0 1)4 (0 1 0 0) ↑ ↑ The above arrows point to positions where the corresponding bits are different. 나의 풀이 ※ 해밍거리(Hamming Distance)블록 부호 이론에서, 해밍 거리(Hamming距離, 영어: Hamming distance)는 곱집합 위에 정의되는 거리 함수이다. 대략, 같은 길이의 두 문자열에서, 같은 위치에서 서로 다른 기호들이 몇 개인지를 센다. 주어진 값들을 이진수 형태에서 비교해서 같은 위치에 다른 수가 몇개인지를 세면 되는 것 같다. 이진수로 바꾸는 방법은 toString 메소드를 사용했고, 수에 따라 같은 길이가 아닐 수 있으니 뒤의 수부터 비교해주기로 했다.sort를 이용해 길이가 긴 수를 정해서 reduce를 통해 그 길이에 수가 둘 다 있으면 두 수(문자)를 비교해 다르면 누적에 1을 더하고 만약 위치에 수가 없으면 수가 있는 배열의 값이 ‘1’일 경우 더한다. 12345678910111213// 56 msvar hammingDistance = function(x, y) &#123; const arr = [x.toString(2).split('').reverse(), y.toString(2).split('').reverse()].sort((a, b) =&gt; b.length - a.length); return arr[0].reduce((acc, item, index, array) =&gt; &#123; if(arr[1][index] &amp;&amp; arr[1][index] !== item) &#123; return acc + 1 &#125; else if (!arr[1][index] &amp;&amp; item === '1') &#123; return acc + 1 &#125; else &#123; return acc &#125; &#125;, 0)&#125;; 다른 사람 풀이이걸 한 줄로 푸네… 1234// 60msvar hammingDistance = function(x, y) &#123; return (x ^ y).toString(2).split('0').join('').length;&#125;; 1. ^(Bitwise XOR) MDN - ^(Bitwise XOR) 위키백과 - 배타적 논리합 ^부분이 이해가 안되었는데 XOR이라는 연산자로 다음의 표와 같이 a와 b가 다른 경우 1을 산출한다고 한다. a b a XOR b 0 0 0 0 1 1 1 0 1 1 1 0 비트 연산자는 피연산자를 10진수나 16진수나 8진수와 같은 숫자가 아니라, 32비트(0과 1)의 집합으로 표현한다. 1234. 9 (base 10) = 00000000000000000000000000001001 (base 2) 14 (base 10) = 00000000000000000000000000001110 (base 2) --------------------------------14 ^ 9 (base 10) = 00000000000000000000000000000111 (base 2) = 7 (base 10) 그렇다면 위의 풀이에서 x, y 간의 배타적 논리합을 구해서 그 수의 이진수 표현(문자열) 중 문자 ‘0’을 제거하면(split(‘0’)) ‘1’만 남게 되는 데 이 1은 x, y가 같은 위치에 다른 문자였음을 의미하니까 그 길이를 구하면 원하는 결과를 얻을 수 있다. 다만, 왜 이 풀이가 내 풀이보다 느린 지 아직 잘 모르겠다. 처음에는 32비트 집합간의 비교라서 그런건가 했는데 비트가 더…느릴 수…있나? 왠지 환경에 따라 다를 것 같은 미미한 차이라…","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://chiabi.github.io/categories/Algorithm/"}],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://chiabi.github.io/tags/algorithm/"},{"name":"leetcode","slug":"leetcode","permalink":"http://chiabi.github.io/tags/leetcode/"}]},{"title":"flip And Invert Image","slug":"flipAndInvertImage","date":"2018-07-15T13:42:39.000Z","updated":"2018-07-17T15:54:44.580Z","comments":true,"path":"2018/07/15/flipAndInvertImage/","link":"","permalink":"http://chiabi.github.io/2018/07/15/flipAndInvertImage/","excerpt":"","text":"leetcode 문제링크 Given a binary matrix A, we want to flip the image horizontally, then invert it, and return the resulting image. To flip an image horizontally means that each row of the image is reversed. For example, flipping [1, 1, 0] horizontally results in [0, 1, 1]. To invert an image means that each 0 is replaced by 1, and each 1 is replaced by 0. For example, inverting [0, 1, 1] results in [1, 0, 0]. Example 1: Input: [[1,1,0],[1,0,1],[0,0,0]] Output: [[1,0,0],[0,1,0],[1,1,1]] Explanation: First reverse each row: [[0,1,1],[1,0,1],[0,0,0]]. Then, invert the image: [[1,0,0],[0,1,0],[1,1,1]] Example 2: Input: [[1,1,0,0],[1,0,0,1],[0,1,1,1],[1,0,1,0]] Output: [[1,1,0,0],[0,1,1,0],[0,0,0,1],[1,0,1,0]] Explanation: First reverse each row: [[0,0,1,1],[1,0,0,1],[1,1,1,0],[0,1,0,1]]. Then invert the image: [[1,1,0,0],[0,1,1,0],[0,0,0,1],[1,0,1,0]] Notes: 1 &lt;= A.length = A[0].length &lt;= 20 0 &lt;= A[i][j] &lt;= 1 나의 풀이문제를 요약하면 0과 1로만 이루어진 2차원 배열을 수평으로 한번 뒤집고, 0은 1로 1은 0으로 치환되면 된다.이미지 파일을 뒤집는 방법이 이런식으로 이루어지나 보다. 1234567891011// 72 msvar flipAndInvertImage = function(A) &#123; const arr = A; for (let i = 0, l = arr.length, n = arr[0].length; i &lt; l; i++) &#123; arr[i].reverse(); for (let j = 0; j &lt; n; j++) &#123; arr[i][j] = arr[i][j] === 1 ? 0 : 1; &#125; &#125; return arr;&#125;; 2차원 배열이니 for문을 2번 썼다.for문을 두번 쓰는 다음과 같은 경우에는 적절한 것 같은데, reverse가 원본 배열을 바꾸는 메소드이고 arr[i][j]에 값을 대입하는 부분 역시 원본 배열에 변화를 주기 때문에 만약에 원본 배열에 영향을 주고 싶지 않다면 깊은복사를 할 수 있도록 고려해야 될 것 같다. 그렇다면 다음과 같은 방법을 사용하면 인자로 넘겨지는 원본 배열에 변형 없이 새로운 배열을 얻을 수 있다.123456789101112// 68 msvar flipAndInvertImage = function(A) &#123; const newArr = []; for (let i = 0, l = A.length, n = A[0].length; i &lt; l; i++) &#123; const newRow = A[i].concat().reverse(); for (let j = 0; j &lt; n; j++) &#123; newRow[j] = newRow[j] === 1 ? 0 : 1; &#125; newArr.push(newRow); &#125; return newArr;&#125;; 또 다른 방법으로 for of 문을 쓰면서 map 메소드를 사용하는 방법을 써봤다. 123456789// 64 msvar flipAndInvertImage = function(A) &#123; const newArr = []; for (const i of A) &#123; const newRow = i.concat().reverse().map(item =&gt; item === 1 ? 0 : 1) newArr.push(newRow); &#125; return newArr;&#125;; 다른 사람 풀이map을 두번 써서 풀었다. 그런데 이 풀이도 만약에 원본 배열을 바꾸고 싶지 않다면 reverse() 메소드 이전에 복사하는 부분이 없기 때문에 변형이 생긴다.123var flipAndInvertImage = function(A) &#123; return A.map(row =&gt; row.reverse().map(num =&gt; num ? 0 : 1))&#125;;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://chiabi.github.io/categories/Algorithm/"}],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://chiabi.github.io/tags/algorithm/"},{"name":"leetcode","slug":"leetcode","permalink":"http://chiabi.github.io/tags/leetcode/"}]},{"title":"Jewels and Stones","slug":"Stones","date":"2018-07-09T14:19:43.000Z","updated":"2018-07-09T15:21:35.591Z","comments":true,"path":"2018/07/09/Stones/","link":"","permalink":"http://chiabi.github.io/2018/07/09/Stones/","excerpt":"","text":"leetcode 문제링크 You’re given strings J representing the types of stones that are jewels, and S representing the stones you have. Each character in S is a type of stone you have. You want to know how many of the stones you have are also jewels. The letters in J are guaranteed distinct, and all characters in J and S are letters. Letters are case sensitive, so “a” is considered a different type of stone from “A”. Example 1: Input: J = “aA”, S = “aAAbbbb” Output: 3 Example 2: Input: J = “z”, S = “ZZ” Output: 0 Note:S and J will consist of letters and have length at most 50.The characters in J are distinct. 나의 풀이오랜만에 풀려니 머리가 잘 굴러가지 않는데 그럴땐 일단 가장 단순 무식한 방법으로 (Brute force 식으로) 풀어버리는 게 가장 좋은 것 같다. 123456789101112// 60msvar numJewelsInStones = function(J, S) &#123; let num = 0; const jArr = J.split(''); const sArr = S.split(''); for (let i = 0, l = jArr.length; i &lt; l; i++) &#123; for (let j = 0, m = sArr.length; j &lt; m; j++) &#123; sArr[j] === jArr[i] &amp;&amp; num++; &#125; &#125; return num;&#125;; 아니 근데 반복문 2번은 돌려야 풀 수 있는 문제네;;12345678910// 64msvar numJewelsInStones = function(J, S) &#123; let num = 0; for (const i of J) &#123; for (const j of S) &#123; j === i &amp;&amp; num++ &#125; &#125; return num;&#125;; 다른 사람 풀이reduce 메서드를 이용한 방법12345678910// 52msvar numJewelsInStones = function(J, S) &#123; const jewels = J.split(''); return S.split('').reduce(function(a, b) &#123; if(jewels.includes(b)) &#123; a += 1; &#125; return a; &#125;, 0)&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://chiabi.github.io/categories/Algorithm/"}],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://chiabi.github.io/tags/algorithm/"},{"name":"leetcode","slug":"leetcode","permalink":"http://chiabi.github.io/tags/leetcode/"}]},{"title":"TIL 20180624","slug":"TIL","date":"2018-06-24T11:24:53.000Z","updated":"2018-06-24T13:41:27.780Z","comments":true,"path":"2018/06/24/TIL/","link":"","permalink":"http://chiabi.github.io/2018/06/24/TIL/","excerpt":"","text":"오늘 한 일파이널 프로젝트 팀 명: geek-ryan 프로젝트 명: seemva Ant Design 테스트리액트 컴포넌트로 제공하거나 form 같은 경우 verify 해주는 부분의 가이드를 제공해준다. 나중에 만들어 볼지도 모를 calendar컴포넌트도 제공하고, airbnb의 datapicker를 사용하려고 했었는데, 이 역시 컴포넌트로 제공하고 있다. timeline 컴포넌트는 프로젝트에서 쓰려고 하는 것과 맞지 않아서 아쉽지만…각자 테스트 해본 뒤 방향을 결정하기로 했는데, 논의 끝에 우선 이 디자인 컴포넌트를 이용해 보기로 했다. 와이어프레임각자 벤치마킹을 해보고 와이어프레임을 그려보기로 했다. 논의는 트렐로를 통해 이루어졌다. 벤치마킹한 사이트의 이미지나 링크를 트렐로를 통해 공유하고, 팀원이 손그림으로 와이어프레임을 그린 것을 트렐로에 올린 것을 카카오 oven을 통해 정리했다.로그인, 회원가입, 보드 화면까지만 만들었는데, 한꺼번에 하기보다는 먼저 컴포넌트별, 페이지별로 개발을 들어가면서 수정하고 추가하는 식으로 진행하는 것이 좋을 것 같다. 로그인, 회원가입: chiabi 보드화면, 보드의 사이드바: akiraei 네이밍 컨벤션 예. Login form directory : filename components: UserFormButtonPC.js containers:UserFormButtonCC.js contexts: UserFormCTX.js pages: LoginPage.js hocs: withAuth.js serverAPI.js ※ components 파일에서 PC 작성시 반드시 storybook 파일 남길 것UserFormButtonPC.stories.js ※ 되도록 축약 표현이 아닌 풀 네임으로 만들것 (Btn(x), Button(o)) 앞으로 사용 예정인 라이브러리 드래그앤 드롭 - react-dnd 타임라인 - react-calendar-timeline 프로필 부분은 고민이다. 사진을 올릴 수 있어야하는데, 이미지 서버를 따로 두는 방법을 고민 중이다. 이부분을 내가 테스트해보기로 해서 로그인과 회원가입 부분을 맡기로 했다.","categories":[{"name":"TIL","slug":"TIL","permalink":"http://chiabi.github.io/categories/TIL/"}],"tags":[{"name":"TIL","slug":"TIL","permalink":"http://chiabi.github.io/tags/TIL/"}]},{"title":"TIL 20180622","slug":"TIL","date":"2018-06-22T15:12:20.000Z","updated":"2018-07-17T17:09:59.754Z","comments":true,"path":"2018/06/23/TIL/","link":"","permalink":"http://chiabi.github.io/2018/06/23/TIL/","excerpt":"","text":"오늘 한 일1. 프론트엔드 개발 스쿨강사님이 게시판 게시글 CRUD와 댓글은 보여주는 것 까지만 구현하신 코드를 보면서 설명해주셨다.코드를 보니 또 내가 생각한 것과는 context 설계가 달랐다. 나는 post 폼은 PostListContext.js(componentDidMount 훅에 서버로 포스트 리스트에 대해서 GET 요청을 보내는 부분이 있는)에 서버에 POST하는 메소드를 추가해서 post 폼 컨테이너로 내려보내고, 나중에 post 폼 수정 페이지에서는 PostContext.js(componentDidMount 훅에 서버로 특정 포스트에 대해서 GET 요청을 보내는 부분이 있는)에 PATCH 요청을 보내는 메소드를 추가해서 내려보내는 식으로 해서 context를 같이 사용하려고 했는데, 강사님은 폼 추가/삭제에 대한 context를 따로 만들어서 id가 있을 경우에 따라 조건문을 통해 componentDidMount 훅에서 특정 포스트에 대한 GET 요청을 보내는 식으로 구현하셨다.그리고 내가 간과하고 있던 것이 나는 게시글 추가 시에 게시판 목록으로 Redirect를 걸었는데 생각해보니 사용자의 관점에서는 게시글 목록이 아니라 생성된 게시글의 보기 페이지로 Redirect를 걸어주는 게 맞는 것 같다. 그리고 페이지는 함수형 컴포넌트로 만들었는데, 그러면서 화살표 함수로 만들면서 익명함수로 만든게 개발자 도구에서는 Unknown으로 보인다는 것도 알게 되었다. 그리고 Router부분을 나는 이슈 페이지에서 찾은 코드를 추가했는데, storybook-react-router라는 라이브러리가 있어서 그걸 쓰면 더 간략한 코드로 내가 처리한 부분을 대체할 수 있었다. 나는 Components 디렉터리의 PC 컴포넌트에서 username이나 password 상태를 관리하고 Context의 메소드를 내려받아서 핸들링해줬는데, 강사님은 Container에서 처리해주셨다. 이부분은 따로 여쭤봤는데, 물론 PC에서 관리해도 그것은 어떻게 설계하느냐(말하자면 관리 정책 측면이라)에 따른 거라 문제 될 것은 없지만, 로그인의 경우 사용자 입력을 받아 서버에 요청을 보내고 성공했는지에 따라 success 상태를 토글해서 Redirect를 걸어준다면 그 부분은 외부와 연동되는 부분이 들어가게 되니까 CC에서 처리하는 게 좋을 거라고 생각했다고 하셨다. 2. 파이널 프로젝트 회의파이널 프로젝트로 쇼핑몰을 할 지 기존에 템플릿으로 만들어봤던 프로젝트 관리 서비스를 만들지 고민했다. 팀원이랑 의논 끝에 기존에 만들어본 프로젝트 관리 서비스를 하는 대신에 규모를 더 키워보기로 했다. 이전에는 사용자의 프로젝트 todo 리스트에 가까웠다면 이번에는 아예 팀 별로 프로젝트를 생성해서 관리할 수 있는 트렐로, asana 같은 서비스를 만들어보기로 했다.(물론 그들이 제공하는 모든 기능을 구현할 수는 없겠지만) 그리고 라이브러리를 이용해 타임라인과 캘린더 보기까기 구현해보기로 계획했다.오늘 강사님이 알려주신 eslint와 prettier 설정으로 코딩 스타일은 얼추 맞출 수 있게 되었고, 구체적으로 설계하는 부분은 같이 맞춰나가기로 했다. 기능단위로 PC를 먼저 구현한 뒤에 일단 Context를 만들어 상태를 관리하고 Context에서 보관할 필요가 없는 상태라면 CC에서 처리해주기로 했다. 오늘은 일단 프로젝트를 어느정도 규모로 할 지와 나중에 수정할지라고 일단 컴포넌트 작성 순서와 상태 관리를 어디에서 할 건지 먼저 정하고, 내일은 일단 어느정도 와이어프레임을 위해 각자 벤치마킹을 해보고 일요일까지 와이어프레임을 만든 뒤 기능 별 분담을 하기로 했다. 2주내에 다 할 수 있을까 조금 걱정이 되긴 하는데, 만드는 것은 재미있을 것 같다. 목표한대로 1주 정도는 전체적으로 만들고 남은 기간에는 스타일링과 코드 개선을 할 수 있으면 좋겠다. 내일 할 일 파이널 프로젝트 와이어프레임을 위한 벤치마킹 강사님 게시판 코드 읽어보고 연습하기 Ant Design 써보기","categories":[{"name":"TIL","slug":"TIL","permalink":"http://chiabi.github.io/categories/TIL/"}],"tags":[{"name":"TIL","slug":"TIL","permalink":"http://chiabi.github.io/tags/TIL/"}]},{"title":"TIL 2018021","slug":"TIL","date":"2018-06-21T14:24:55.000Z","updated":"2018-06-22T15:17:37.746Z","comments":true,"path":"2018/06/21/TIL/","link":"","permalink":"http://chiabi.github.io/2018/06/21/TIL/","excerpt":"","text":"오늘 한 일1. 리액트로 게시판 만들기다 완성하고 싶었는데, 오류도 잡고 어떻게 만들어야할까 고민하다보니 댓글까지는 넣지 못했다.원래는 PostList와 Post Context로 분리하지 않고 Post Context 하나로 모든 상태를 같이 관리하려고 했는데, 강사님이 보여주신 코드를 보니 list와 view에서 쓸 수 있는 Context를 따로 나누셨다. 왜 그렇게 하셨을까 생각을 해보니 나는 어차피 post를 모두 불러오니까 그걸로 filter메소드 등을 써서 특정 id의 post를 찾으면 되지 않을까라고 생각했는데(뷰페이지는 그렇게 만들기까지 했었다.), 새 글 작성은 몰라도 글을 수정하는 페이지를 어떻게 처리할 건가 생각해보니 componetDidMount시에 보내는 요청이 다르기 때문에 따로 context를 분리하는 게 더 나을것 같아서 수정했다.router 사용시 ‘/post’(리스트) ‘/post/write’(새 글 작성), ‘/post/1’(뷰페이지) 이렇게 주소가 표시되도록 하려고 했는데, write 페이지가 렌더링 되지 않았다. 이유는 ‘/post/write역시 ‘/post/:postId’ Route에 걸리기 때문이었다. ‘/post/write’ Route에 exact를 추가하고 위로 올리니 해결되었다.그 다음 문제는 write페이지에서1GET https://&#123;server&#125;/posts/write?_expand=user 404 () 이런식으로 404에러를 던지고 있는데, 왜 저런식으로 요청을 보내나했더니 처음에는 &lt;Route&gt;를 &lt;Switch&gt;로 둘러줬다가 exact를 쓰니까 제거해도 되지 않을까 했는데, 그렇게 되면 write일때도 걸리고 post의 params로도 걸려서 뷰페이지도 렌더링 되고 있었다. 다시 &lt;Switch&gt;로 둘러줘서 하나의 Route만 걸리도록 했더니 해결되었다.스토리북에서 테스트하는 컴포넌트에 react router의 컴포넌트 사용으로 오류가 자꾸 발생되었는데, 이부분은 찾아보니 스토리북 깃헙에 이슈로 올라와 있었다. addDecorator를 이용한 해결방법도 찾을 수 있었다. 내일 할 일 파이널 프로젝트 기획하기","categories":[{"name":"TIL","slug":"TIL","permalink":"http://chiabi.github.io/categories/TIL/"}],"tags":[{"name":"TIL","slug":"TIL","permalink":"http://chiabi.github.io/tags/TIL/"}]},{"title":"TIL 20180620","slug":"TIL-1","date":"2018-06-20T13:23:10.000Z","updated":"2018-06-21T14:44:45.963Z","comments":true,"path":"2018/06/20/TIL-1/","link":"","permalink":"http://chiabi.github.io/2018/06/20/TIL-1/","excerpt":"","text":"1. 프론트엔드 스쿨과정 - 리액트 HOC로 인증 관련 문제 해결하기 defaultProps Sass 사용하기 classnames 규모있는 프로젝트의 개발 순서는 어떻게 가져가야 할까? Sass 사용은 visual studio code에서 바로 컴파일 해주는 익스텐션을 사용하도록 알려주셨는데, 시간이 나면 webpack을 이용하는 방법을 알아봐야겠다. 2. 리액트로 게시판 만들기기본적인 로그인 구현까지했다. 스토리북을 이용해서 Presentational 컴포넌트를 먼저 확인하면서 만들고 있다. 만들다가 기억이 잘 안나는 부분은 다시 todo 실습으로 돌아가서 참고하고 있는데, rgb 챌린지처럼 먼저 단순하게 만들고 더 다듬어야 될 것 같다. 아직 어느 코드가 중복되는 로직일지 파악할 수 없어서 오늘 배운 HOC은 적용해보지 못했는데, 다듬다보면 어느때 써야할 지 감이 잡힐 것 같다. 이번 과제로 게시판을 한번 만들어보면 마지막 과제를 할 때 많은 도움이 될 것 같다. 내일 할 일 리액트로 게시판 만들기 과제 완료하기 로그인 데이터설계(json server) presentational: 로그인 화면 Provider: 상태관리 Container 컴포넌트 (PC와 Provider를 이어줄) 글 목록 글 작성 댓글 목록","categories":[{"name":"TIL","slug":"TIL","permalink":"http://chiabi.github.io/categories/TIL/"}],"tags":[{"name":"TIL","slug":"TIL","permalink":"http://chiabi.github.io/tags/TIL/"}]},{"title":"TIL 20180619","slug":"TIL","date":"2018-06-19T16:26:50.000Z","updated":"2018-06-21T14:29:49.036Z","comments":true,"path":"2018/06/20/TIL/","link":"","permalink":"http://chiabi.github.io/2018/06/20/TIL/","excerpt":"","text":"오늘 한 일1. 프론트엔드 스쿨과정 - 리액트 Provider의 적절한 위치는? 마운트되었을 때 부작용을 일으키는 컴포넌트 (OnMount 컴포넌트) 브라우저의 중요한 UI - 주소표시줄, hash, 새로고침, 뒤로가기, 앞으로가기 HTML5 history API &amp; hashchange react-router 소개 및 실습 ‘만약 단순한 모달 정도가 아니라 페이지가 이동되는 것 같이 느껴지도록 만들려면 리액트로 어떻게 해야하지?’ 라는 고민이 해결되었다. 리액트 라우터를 통해 굉장히 쉽게 구현할 수 있었다. 강사님께서 리액트 라우터에 대해 설명하기 전에 마운트되었을 때 부작용을 일으키는 컴포넌트나 history객체, pushState 같은 바탕이 되는 개념을 먼저 설명해주셔서 덕분에 크게 어렵게 느껴지지 않았다.리액트 라우터를 배우고 나니 파이널 프로젝트에서는 쇼핑몰을 도전해보고 싶어졌다. 2. rgb 챌린지 게임 수정강사님이 코드 리뷰를 해주신 것을 토대로 다시 수정했다. 컬러 코드, 스테이지, 점수 등이 서로 결합되어 있기 때문에 GameContext라는 하나의 컴포넌트에서 모든 상태를 관리하는 방법으로 해볼 것을 조언해주셔서 ColorContext와 ResultContext, ScoreContext로 나눴던 것을 GameContext로 합쳤다. 그리고 GameConsumer를 사용하게 되는 부분은 Container 컴포넌트로 따로 만들었다.컴포넌트가 너무 많은것이 아닌가 걱정이었는데, context 컴포넌트를 줄였음에도 Presentaional 컴포넌트와 Container 컴포넌트로 분리해보려고 했더니 컴포넌트가 많아졌다.어쩌면 내가 잘못 쓰고 있는 건 아닌지;;강사님이 번역해주신 dan Abramov의 아티클을 다시 읽어봤는데, 잘 사용하고 있는지 아직은 개념이 어렵게 느껴진다. 내일 또 여쭤봐야겠다. 내일 할 일 리액트 미니 프로젝트 - social card 만들기(트위터 참고) 자기소개서 최종 검토하기","categories":[{"name":"TIL","slug":"TIL","permalink":"http://chiabi.github.io/categories/TIL/"}],"tags":[{"name":"TIL","slug":"TIL","permalink":"http://chiabi.github.io/tags/TIL/"}]},{"title":"TIL 20180618","slug":"TIL","date":"2018-06-18T15:49:40.000Z","updated":"2018-06-18T16:07:20.849Z","comments":true,"path":"2018/06/19/TIL/","link":"","permalink":"http://chiabi.github.io/2018/06/19/TIL/","excerpt":"","text":"오늘 한 일프로트엔드 스쿨과정 - 리액트 children prop 로그인 시 예외 처리 (비동기 예외처리) ref와 “제어되지 않는 컴포넌트”로 폼 바꿔보기 Presentational component &amp; Container component Storybook 제어되지 않는 컴포넌트 부분은 break week 기간에 잠깐 튜토리얼 따라해 보면서 봤던 부분인데 다시 복습하게 되었다. form의 기본 submit 기능을 사용하게 되면, 따로 이벤트 메서드를 만들지 않아도 되어 코드가 간결해지는 장점이 있지만, 나중에 폼을 쓰게 될 경우 유효성 검사를 하거나 키보드 접근 관련해서 추가적인 처리를 하게 될 것 같아서 대부분의 경우 제어되는 컴포넌트로 하게 되지 않을까 싶다. 프레젠테이션과 컨테이너 컴포넌트 관련 글은 전날에 올려주셔서 자기 전에 읽어봤는데, 읽어보니 왠지 rgb챌린지 만들면서 이 둘을 잘 구분해서 사용하지 않은 것 같다고 느꼈다. 또 글이 잘 이해가 안되었는데, 오늘 수업을 통해 조금 정리되는 느낌이다. 오늘 읽은 글 Context API가 Redux를 대체할 수 있을까요? Presentiational and Container Components(번역) When do I know I’m ready for Redux? 내일 할 일 내일 수업 내용 복습(리액트 라우터를 들어간다고 한다.) 스토리북 사용해보기 리덕스 일단 따로 Dan abramov의 소개 영상 보면서 감 잡기","categories":[{"name":"TIL","slug":"TIL","permalink":"http://chiabi.github.io/categories/TIL/"}],"tags":[{"name":"TIL","slug":"TIL","permalink":"http://chiabi.github.io/tags/TIL/"}]},{"title":"TIL 20180617","slug":"TIL","date":"2018-06-17T10:13:10.000Z","updated":"2018-06-18T16:07:21.673Z","comments":true,"path":"2018/06/17/TIL/","link":"","permalink":"http://chiabi.github.io/2018/06/17/TIL/","excerpt":"","text":"오늘 한 일1. 리액트 RGB Challenge 완성공식문서 Context 파트와 지난 수업 시간했던 todo 리스트 실습을 참고해서 context를 사용해 완성했다. 만들다보니 컴포넌트를 굉장히 많이 나누게 되었는데, 그러다보니 DOM API로 단순하게 만들었던 것이 굉장히 복잡해진 것 같아서 내가 제대로 만든 건지 확신이 없다. context는 컬러, 스코어, 결과로 나눠서 각 파일을 따로 만들다.setState()로 각 상태를 변화시키는 메서드를 따로 만들었는데, 예를들면 스코어에서는 upScore, reset으로 하나는 score를 추가해주는 것 하나는 score를 다시 0으로 만드는 메서드이다. 결과 context에서는 showResultGood, showResultBad, reset으로 각각 상태에 ‘good’, ‘bad’, 빈 문자열로 수정하는 메서드이다.이렇게 하는게 맞는 것일까 아니면 메서드는 하나만 만들고 나중에 사용할 때 값을 던져주는 것을 인자로 받아서 setState에 던져주도록 만들어야했을까… 이런저런 사용법에 고민이 많아진다.역할과 책임이라는 것에 신경쓰면서 만드려고 했는데, 잘 한건지는 모르겠다. 좀 더 다른 사람들의 코드나 글을 읽어봐야겠다. 만들면서 그동안 배운것을 다시 정리하고 context를 좀 더 이해하게 되었다. 강사님이 오늘 읽으려고 해두었던 글을 번역해서 올려주셔서 그걸 읽어보고 다시 고민해봐야겠다. 2. 알고리즘 문제 풀이1일 1알고리즘 하려고 하는데 지키기 힘든 일인 것 같다. 특히나 문제가 어려우면 고민하다가 하루가 지나가버린다. 지금은 리액트를 익히는 것 역시 중요하니까 우선순위를 정해서 신간 분배를 잘 해야 될 것 같다. 내일 할 일 리덕스 예습/복습 리액트로 다른 미니 프로젝트 하기(캘린더 다시 만들어본다거나)","categories":[{"name":"TIL","slug":"TIL","permalink":"http://chiabi.github.io/categories/TIL/"}],"tags":[{"name":"TIL","slug":"TIL","permalink":"http://chiabi.github.io/tags/TIL/"}]},{"title":"Longet Common Prefix","slug":"Longet-Common-Prefix","date":"2018-06-17T09:08:46.000Z","updated":"2018-07-09T14:22:56.925Z","comments":true,"path":"2018/06/17/Longet-Common-Prefix/","link":"","permalink":"http://chiabi.github.io/2018/06/17/Longet-Common-Prefix/","excerpt":"","text":"leetcode 문제링크 Write a function to find the longest common prefix string amongst an array of strings. If there is no common prefix, return an empty string “”. Example 1: Input: [“flower”,”flow”,”flight”] Output: “fl” Example 2: Input: [“dog”,”racecar”,”car”] Output: “” Explanation: There is no common prefix among the input strings.Note:All given inputs are in lowercase letters a-z. 나의 풀이더 좋은 방법이 생각나지 않아서 일단 난폭하게 for 문 두 번 돌려서 풀어보기로 했다. 이렇게 하지 않고 푸는 방법이 있을까… 생각이 안 난다.배열에 아무것도 들어있지 않은 경우도 고려한 문제였던 모양이다. 계속 런타임 에러가 나길래 보니 빈 배열이 들어가고 있었다.for문을 두 번 돌렸지만, 어차피 prefix 찾는 거라서 앞에서 일치하는 경우 외에는 버리기 때문에 return으로 종료시켜 버렸다.123456789101112131415// 64msvar longestCommonPrefix = function(strs) &#123; const first = strs[0]; if (first == null) return ''; let str = ''; for(let i = 0, il = first.length; i &lt; il; i++) &#123; for(let j = 1, jl = strs.length; j &lt; jl; j++) &#123; if(first[i] !== strs[j][i]) &#123; return str; &#125; &#125; str += first[i]; &#125; return str;&#125;; 1234567891011121314151617// 60msvar longestCommonPrefix = function(strs) &#123; const first = strs[0]; if (first == null) return ''; const newStrs = strs.slice(1); let str = ''; let i = 0; while(i &lt; first.length) &#123; if(newStrs.every((item) =&gt; item[i] === first[i])) &#123; str += first[i] &#125; else &#123; return str; &#125; i++; &#125; return str;&#125; 배열의 every 메서드와 while로 풀어봤다. 속도가 크게 개선되지는 않았다. 다른 사람 풀이12345678910111213141516// 50msvar longestCommonPrefix = function(strs) &#123; if(!strs.length) return ''; if(strs.length === 1) return strs[0]; let prefix = strs[0]; for(let i in strs) &#123; while(strs[i].indexOf(prefix) !== 0) &#123; prefix = prefix.substring(0, prefix.length - 1); if(!prefix.length) return ''; &#125; &#125; return prefix; &#125;; 나와 다른 접근법이다. 나는 배열에 있는 요소의 인덱스를 앞에서부터 돌면서 그 인덱스의 문자열이 모두 같으면 str에 더해서 prefix를 만들어 반환했는데,여기는 일단 첫번째 문자열을 prefix라 가정하고 시작한다. 배열의 요소를 하나씩 순회하면서 prefix와 일치하는 문자열을 가지지 않으면 prefix에서 거꾸로 문자를 줄여가며 대조한다. 그렇다면 첫번째 문자열은 이미 prefix인데 for in문으로 첫번째 요소를 굳이 돌 필요가 있나 했는데, for loop로 인덱스 1부터 도는 것보다 어차피 while문 조건에 걸려서 다음 요소로 넘어가니까 for in문을 쓰는 게 더 빠른가보다.(환경에 따라 다를 수 있겠지만) 핵심은 indexOf의 사용인 것 같다. 문자열 하나씩 더하는 것보단 문자열 뭉치가 있는 지 확인하는 것이 더 효율적이니까. 12345678910111213// 56msvar longestCommonPrefix = function(strs) &#123; if(!strs.length) return ''; if(strs.length === 1) return strs[0]; let prefix = strs[0]; for (let i = 1, l = strs.length; i &lt; l; i++) &#123; while(strs[i].indexOf(prefix) !== 0) &#123; prefix = prefix.substring(0, prefix.length - 1); if(!prefix.length) return ''; &#125; &#125; return prefix;&#125;;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://chiabi.github.io/categories/Algorithm/"}],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://chiabi.github.io/tags/algorithm/"},{"name":"leetcode","slug":"leetcode","permalink":"http://chiabi.github.io/tags/leetcode/"}]},{"title":"TIL 20180616","slug":"TIL-1","date":"2018-06-16T11:54:09.000Z","updated":"2018-06-16T14:27:53.512Z","comments":true,"path":"2018/06/16/TIL-1/","link":"","permalink":"http://chiabi.github.io/2018/06/16/TIL-1/","excerpt":"","text":"오늘 한 일Context 복습context를 복습하면서 리액트를 단순하게 사용해본 RGB 챌린지를 수정하고 있다. 리액트 공식문서를 읽어보고, velopert님의 context API관련 예제도 따라해봤다.공식문서를 읽어보니 어떻게 쓰는 지는 이해가 되는데, 그래서 어디까지 context를 써주는 것이 좋은지, 코드를 어떻게 관리되도록 설계하는 것이 좋은지는 아직 감이 안잡힌다.일단 context를 활용해서 전체적으로 이벤트까지 완료한 뒤에 강사님이 공유해 주신 Dan Abramov의 ‘Presentational and Container Components’라는 글을 다시 읽어봐야겠다. 예제를 따라하는 중에 import React, {Component} from &#39;react&#39; 이하 클래스를 만드는 거나 export시키는 부분은 react 사용하면서 거의 패턴처럼 치게 되니까, vscode의 사용자 코드 조각에 스니펫으로 만들어 두었다. 내일 할 일 RGB 챌린지 context 완성하기 Redux 예습하기 소프트웨어 공학 시간에 정리한 글 다시 다듬어서 올리기 날이 더워졌다. 에어컨 바람이 간절해진다. 더워질수록 체력 관리를 해야겠다. ‘앞으로 할 일’이라고 썼던 것을 ‘내일 할 일’로 쓰려고 한다. 다 수행하지 못하더라도 내일 할 일로 정해놓으면 더 강제적으로 하게 될 것 같다. 일주일간 블로그를 해보니 장단점이 있다. 일단 글을 좀 더 다듬게 되고, 글 자체가 정제되어 보이는 장점이 있다.단점은 그냥 깃헙에는 자유롭게 덜 완성된 글이나 정리도 올렸는데, 블로그는 그렇게 하는 것이 쉽지 않아졌다. 물론 누가 잘못된 정보라고 지적하는 게 두려운 것은 아니다. 누가 내 글에 관심을 가져주고, 내가 잘못 알고 있는 부분을 바로잡아 주는 것은 감사한 일이나, 혹시라도 내가 잘못된 정보를 제공하지는 않을까하는 우려도 된다.그런데 사실 그런 부분을 걱정하기 이전에 검색 엔진 최적화 방법을 알아봐야겠다…;;","categories":[{"name":"TIL","slug":"TIL","permalink":"http://chiabi.github.io/categories/TIL/"}],"tags":[{"name":"TIL","slug":"TIL","permalink":"http://chiabi.github.io/tags/TIL/"}]},{"title":"TIL 20180615","slug":"TIL","date":"2018-06-15T16:13:22.000Z","updated":"2018-06-16T14:32:25.736Z","comments":true,"path":"2018/06/16/TIL/","link":"","permalink":"http://chiabi.github.io/2018/06/16/TIL/","excerpt":"","text":"오늘 한 일프론트엔드 개발 과정 - 특강 [소프트웨어 공학]어제 한 과제는 기능 명세가 아니었던 것 같다. 화면설계 전 단계였던듯… why? 도출보다는 상세한 기능 기술이었던 것 같다…수업시간에 클라이언트가 블록체인 거래소를 만들려고 한다는 상황을 가정해서 요구사항을 분석하고, 클라이언트(강사님)에게 질문하는 식으로 진행되었는데, 블록체인이라는 기술 자체를 잘 몰라서 질문을 할 수가 없었다.웹 사이트를 볼때 그냥 보는 것이 아니라 어떤 기술을 사용했고, 어떤 콘텐츠로 이루어져있는지 분석해봐야겠다. 그리고 블록체인이라는 기술 자체에도 관심을 기울여야겠다. 앞으로 할 일 RGB 챌린지 context 활용하기 Redux 미리 예습하기","categories":[{"name":"TIL","slug":"TIL","permalink":"http://chiabi.github.io/categories/TIL/"}],"tags":[{"name":"TIL","slug":"TIL","permalink":"http://chiabi.github.io/tags/TIL/"}]},{"title":"Palindrome Number","slug":"Palindrome-Number","date":"2018-06-14T17:37:32.000Z","updated":"2018-06-17T09:10:54.176Z","comments":true,"path":"2018/06/15/Palindrome-Number/","link":"","permalink":"http://chiabi.github.io/2018/06/15/Palindrome-Number/","excerpt":"","text":"leetcode 문제링크 Determine whether an integer is a palindrome. An integer is a palindrome when it reads the same backward as forward. Example 1: Input: 121 Output: true Example 2:Input: -121Output: falseExplanation: From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome. Example 3:Input: 10Output: falseExplanation: Reads 01 from right to left. Therefore it is not a palindrome. Follow up:Coud you solve it without converting the integer to a string? 예?? 이걸 문자열화 하지 말고 풀라구요??? 나의 풀이난이도 easy만 먼저 풀어보는데 속도에 집착하다보니 난이도가 easy가 아닌 것만 같은 기분… 123456// 304ms var isPalindrome = function(x) &#123; const str = x.toString(); const reverseStr = str.split('').reverse().join(''); return str === reverseStr&#125;; Hint: Beware of overflow when you reverse the integer. 네..그렇군요… 뒤집는 건 주의해야겠군요…세상에…아래는 while문을 통해 앞 / 뒤로 접근해서 비교하도록 하는 방법인데,1234567891011121314// 268msvar isPalindrome = function(x) &#123; const str = x.toString(); const l = str.length - 1; let i = 0; let result = true; while(i &lt;= l) &#123; if(str[i] !== str[l - i]) &#123; return (result = false); &#125; i++; &#125; return result;&#125; 반으로 나눠야 중복되는 비교를 안하겠구나 생각해서 아래와 같이 수정했지만 속도가 크게 개선되지는 않았다.1234567891011121314151617// 260ms 속도 개선이 별로..var isPalindrome = function(x) &#123; const str = x.toString(); const l = str.length; const half = Math.floor(l / 2); const strF = str.slice(0, half); const strB = str.slice(l % 2 === 0 ? half : half + 1); let i = 0; let result = true; while(i &lt; half) &#123; if(strF[i] !== strB[(half - 1) - i]) &#123; return result = false; &#125; i++; &#125; return result;&#125;; 혹시나 해서 reverse 메소드를 사용하는 방법을 반으로 나눠서 하는 방법으로 다시 풀어봤다.300ms가 280ms로 속도가 개선되었으나 앞의 풀이 방법에 비하면 느리다.123456789101112// 280msvar isPalindrome = function(x) &#123; const str = x.toString(); const l = str.length; if (l === 1) &#123; return true; &#125; const half = Math.floor(l / 2); const strF = str.slice(0, half); const strB = str.slice(l % 2 === 0 ? half : half + 1).split('').reverse().join(''); return strF === strB&#125;; 문자열화하지 않고 숫자인 상태에서 풀면 좀 더 빠를까해서 아래와 같이 풀었는데, 더 느려졌다. 아마 이 역시 주어진 수를 반으로 나눠서 푸는 게 아니라서 그런 것 같다.(수의 길이(?)만큼 비교하게 된다.)1234567891011121314151617// 300ms 아악 더 느려졌다.var isPalindrome = function(x) &#123; if(x &lt; 0) &#123; return false &#125; if(x &lt; 10) &#123; return true &#125; let xClone = x; const arr = []; while(xClone) &#123; const X = xClone % 10; xClone = parseInt(xClone / 10); arr.push(X % 10); &#125; return x === parseInt(arr.join(''))&#125; 뭔가 숫자를 반으로 쪼갤 수 있으면 좋겠는데, 이 부분은 방법이 잘 생각나지 않아서 solution을 보기로 했다.아래는 solution을 참고한 풀이 Approach 1: Revert half of the number12345// C#while(x &gt; revertedNumber) &#123; revertedNumber = revertedNumber * 10 + x % 10; x /= 10;&#125; 이부분을 통해 수를 반으로 나눠 반복문 안에서 비교할 수 있도록 하는 방법이다.C#의 문법을 잘 모르지만 C#은 알아서 소수점 아래는 제거해주는 건지;; 아무튼 소수점 아래가 생겨버리므로 나는 JavaScript로 풀어야하니까 parseInt를 통해 정수로 계산되도록 했다.123456789101112131415// 256msvar isPalindrome = function(x) &#123; let xC = x; if(x &lt; 0 || (x % 10 === 0 &amp;&amp; x !== 0)) &#123; return false; &#125; else if (x &lt; 10) &#123; return true; &#125; let revert = 0; while(xC &gt; revert) &#123; revert = parseInt(revert * 10 + xC % 10); xC = parseInt(xC / 10); &#125; return xC === revert || xC === parseInt(revert / 10);&#125; Complexity Analysis Time complexity : O(log10n)We divided the input by 10 for every iteration, so the time complexity is O(log10n) Space complexity : O(1) 라는데, 복잡성 공부를 해야겠다… 댓글에서는 ‘왜 O(log10n)이냐 O(n)이 맞다’, ‘아니다 솔루션 저자가 맞다’로 의견이 분분한 듯한데 아직 잘 모르겠다;;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://chiabi.github.io/categories/Algorithm/"}],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://chiabi.github.io/tags/algorithm/"},{"name":"leetcode","slug":"leetcode","permalink":"http://chiabi.github.io/tags/leetcode/"}]},{"title":"TIL 20180614","slug":"TIL-1","date":"2018-06-14T11:16:32.000Z","updated":"2018-06-14T17:33:10.493Z","comments":true,"path":"2018/06/14/TIL-1/","link":"","permalink":"http://chiabi.github.io/2018/06/14/TIL-1/","excerpt":"","text":"오늘 한 일1. RGB Challenge 리액트를 이용해 다시 만들어보기전날 배운 context를 이용하는 부분은 잘 이해가 되지 않아서 문서를 봤는데, 일단 todo 리스트 실습때 진행했던 것처럼 컴포넌트, state, props를 통해 단순하게 만들어 보는 것부터 시작해서 하나씩 변경해 봐야할 것 같다.그냥 DOM API로 만들때는 금방 만들었던 것을 구조를 분리해서 컴포넌트 별로 따로 만들고 어떤 것을 상태로 할 지 어떤 것이 컴포넌트 간 공유되는 상태일지를 구분하려니 오히려 오래 걸렸다. 만약 이 게임 자체가 규모가 크다면 이렇게 컴포넌트 별로 분리하는 것은 장기적으로 봤을때 유지보수 하기에는 좀 수월해 질지 모르겠지만 현재 규모에서는 생산성면에서 별로 좋은 방법이 아닌 것 같다. 아직 context를 이용해보지는 못했는데, 역할과 책임에 따라 정리하는 것이 가장 어렵게 느껴졌다.컬러코드 컴포넌트와 공유되는 상태를 관리하는 조상 컴포넌트와의 사이에 컴포넌트가 많아져서 context를 활용해야 할 것 같다.컬러 코드를 랜덤으로 계산해내는 부분은 클래스의 메소드로 만드는 것이 적합하지 않은 것 같아서 따로 함수로 빼냈는데, 이렇게 하는게 맞는지는 꼭 주말까지 완성해서 강사님의 피드백을 들을 수 있도록 해야겠다. 2. 기능명세 작성 과제medical factory 사이트의 로그인 / 회원가입 / 리뷰 페이지를 분석하며 어떤 명세를 통해 만들었을지 명세를 도출해보는 것이 과제였다. 구글 드라이브를 통해 정리했다. 수업시간에 명세를 너무 자세하게 작성하지 말라고 주의해주셨었는데, 자꾸 작성할 것이 늘어나서 이렇게 작성하는게 맞는지 의구심이 든다.;; 찾아보니 기능 명세나 기술 명세에 특별한 폼은 없는 것 같았다. 그래서 그런지 이런식으로 작성해야 한다라고 딱 정리한 글도 찾기 어려웠다.좀 시간이 걸렸지만, 로그인 / 회원가입 같은 경우는 대부분의 서비스에 들어가는 부분이라 왠지 구축할 때 도움이 될 것 같아서 자세히 분석해봤다. 보다보니 생각보다 누락하거나 유효하지 않은 입력에 대해 검증해야 하는 부분이 많았다. 나도 만들때 이런 부분은 신경 써줘야겠다는 생각을 하게되었다. 3. git aliasgit 명령어 몇가지를 alias로 만들어두었다. 만들어두니 git flow ~ 명령을 쓰기가 훨씬 수월해졌다. 12345678alias gfi='git flow init'alias gff='git flow feature'alias gfr='git flow release'alias gfh='git flow hotfix'alias gfs='git flow support'alias gcm='git commit -m'alias npxreact='npx create-react-app' 너무 많으면 또 외워야하고 잘못 사용할 수도 있을 것 같아서 긴 명령어 위주로 이정도만 해두었다.작성에 사용한 명령어는 다음과 같다.1vi ~/.bashrc 앞으로 할 일 RGB 챌린지 주말까지 완성하기(context 사용하기)","categories":[{"name":"TIL","slug":"TIL","permalink":"http://chiabi.github.io/categories/TIL/"}],"tags":[{"name":"TIL","slug":"TIL","permalink":"http://chiabi.github.io/tags/TIL/"}]},{"title":"TIL 20180613","slug":"TIL","date":"2018-06-13T16:28:49.000Z","updated":"2018-06-14T17:06:19.452Z","comments":true,"path":"2018/06/14/TIL/","link":"","permalink":"http://chiabi.github.io/2018/06/14/TIL/","excerpt":"","text":"오늘 한 일1. 프론트엔드 개발 과정 - 리액트 실습수업시간에 Provider와 Consumenr랑 props.children이 등장했다. 정신이 혼미해진다.계속 상태를 필요한 하위 컴포넌트로 내려보내야 한다면 불편하지 않나라고 생각했는데, 그부분을 context를 통해 개선할 수 있단 점이 매력적이지만 역할과 책임에 따라 분리한다거나, 쓰는 방법 자체는 여러번 써봐야겠다. 2. Algorithm 문제 풀이알고리즘 문제를 푸는 건 잘 못하지만 재미있다. 특히 끙끙 거리며 풀었는데, 가장 성능이 좋은 코드와 현저하게 차이가 나면 대체 무슨 방법으로 풀었을까 엄청 궁금하다. 그래도 한번에 보기에는 좀더 고민해야 될 것 같아서 내가 푼 풀이를 좀 더 다듬었는데, 아쉽게도 별로 속도 개선이 되지 않았다. 그래서 다른 사람 풀이를 봤는데, 접근방식이 달랐다.이런 점이 재미있는것 같다. 이런 식으로도 풀수 있구나 대단하다 생각하면서도 앞으로 나도 이렇게 풀어봐야지 하면서 얻게되는 게 있는것 같다. 오늘은 복습을 많이 했어야 했는데, 많이 하지 못했다. 그래도 내가 많이 의지했던 언니의 고민을 들어주고 계속 우울해했던 언니의 기운을 북돋아 줄 수 있어서 오늘 하루에 그렇게 아쉬움은 없다. 대신 내일 정말 열심히 복습해야겠다.","categories":[{"name":"TIL","slug":"TIL","permalink":"http://chiabi.github.io/categories/TIL/"}],"tags":[{"name":"TIL","slug":"TIL","permalink":"http://chiabi.github.io/tags/TIL/"}]},{"title":"Roman to Integer","slug":"Roman-to-Integer","date":"2018-06-13T06:15:36.000Z","updated":"2018-06-14T19:04:30.389Z","comments":true,"path":"2018/06/13/Roman-to-Integer/","link":"","permalink":"http://chiabi.github.io/2018/06/13/Roman-to-Integer/","excerpt":"","text":"leetcode 문제링크 Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M. Symbol Value I 1 V 5 X 10 L 50 C 100 D 500 M 1000 For example, two is written as II in Roman numeral, just two one’s added together. Twelve is written as, XII, which is simply X + II. The number &gt; twenty seven is written as XXVII, which is XX + V + II. Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used: I can be placed before V (5) and X (10) to make 4 and 9.X can be placed before L (50) and C (100) to make 40 and 90.C can be placed before D (500) and M (1000) to make 400 and 900.Given a roman numeral, convert it to an integer. Input is guaranteed to be within the range from 1 to 3999. 나의 풀이1234567891011121314151617// 143 - 152msvar romanToInt = function(s) &#123; const ROMAN = &#123; 'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000 &#125; const newS = s.split('').map(item =&gt; ROMAN[item]); return newS.reduce((acc, item, idx, arr) =&gt; &#123; const before = arr[idx - 1]; return acc + (before &lt; item &amp;&amp; before ? item - (before * 2) : item) &#125;, 0)&#125;; 다른 방법도 생각해보려고 했는데, 도저히… map(), reduce() 메소드로 배열을 두번 탐색한게 마음에 걸린다.123456789101112131415161718// 156msvar romanToInt = function(s) &#123; const ROMAN = &#123; 'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000 &#125; return s.split('').reduce((acc, item, idx, arr) =&gt; &#123; const before = arr[idx - 1]; const beforeInt = ROMAN[before] const itemInt = ROMAN[item] return acc + (beforeInt &lt; itemInt &amp;&amp; beforeInt ? itemInt - (beforeInt * 2) : itemInt) &#125;, 0)&#125; reduce 한번으로 처리하도록 변경했는데 이것도 그닥 속도가 개선되지는 않았다. 다른 사람 풀이1234567891011121314151617181920212223let getIntFromRoman = &#123; I: 1, V: 5, X: 10, L: 50, C: 100, D: 500, M: 1000&#125;;var romanToInt = function(s) &#123; let sum = 0; let curr, next; for(let i = 0; i &lt; s.length-1; i++) &#123; curr = getIntFromRoman[s[i]]; next = getIntFromRoman[s[i+1]]; if(curr &lt; next) sum -= curr; else sum += curr; &#125; return sum + getIntFromRoman[s[s.length-1]];&#125;; for문을 통해 따로 sum 에 더해주는 방식으로 처리했다. 그리고 현재 문자가 다음 문자보다 작으면 오히려 빼주는데, 그렇게 하면 4내지는 9가 나오게 되니 이렇게 풀 수도 있구나하고 깨달음이… 나는 조건 분기했는데…","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://chiabi.github.io/categories/Algorithm/"}],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://chiabi.github.io/tags/algorithm/"},{"name":"leetcode","slug":"leetcode","permalink":"http://chiabi.github.io/tags/leetcode/"}]},{"title":"Add Two Numbers","slug":"Add-Two-Numbers","date":"2018-06-12T12:59:21.000Z","updated":"2018-06-17T09:11:25.294Z","comments":true,"path":"2018/06/12/Add-Two-Numbers/","link":"","permalink":"http://chiabi.github.io/2018/06/12/Add-Two-Numbers/","excerpt":"","text":"leetcode 문제링크 You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list. You may assume the two numbers do not contain any leading zero, except the number 0 itself.Example Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4) Output: 7 -&gt; 0 -&gt; 8 Explanation: 342 + 465 = 807. 나의 풀이123456789101112131415161718192021222324252627282930313233343536373839/** * Definition for singly-linked list. * function ListNode(val) &#123; * this.val = val; * this.next = null; * &#125; */// 124ms, 176msvar addTwoNumbers = function(l1, l2) &#123; const arr = []; const sum = (l1, l2) =&gt; &#123; if (l1 &amp;&amp; l2) &#123; arr.push(l1.val + l2.val) sum(l1.next, l2.next); &#125; else if (!l2 &amp;&amp; l1) &#123; arr.push(l1.val) sum(l1.next); &#125; else if (!l1 &amp;&amp; l2) &#123; arr.push(l2.val) sum(l2.next); &#125; else &#123; return ''; &#125; &#125; sum(l1, l2); let over = false; const newArr = arr.map((item, idx, arr) =&gt; &#123; if(item &gt;= 10) &#123; arr[idx + 1] != null ? arr[idx + 1] += 1 : over = true return item - 10 &#125; else &#123; return item &#125; &#125;); if(over) &#123; newArr.push(1) &#125; return newArr;&#125; 원래 기존 풀이는 200ms인데 좀 줄였다. 연결리스트에 대한 이해가 부족해서 좀 오래 걸렸다.아래 코드가 굉장히 비효율적이라고 느껴서 위의 코드처럼 다시 만들었는데 그렇게 효율적으로 보이지는 않는다.나중에 한번 더 다른 방법으로 풀어보고 다른 사람 풀이를 봐야겠다.1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// 200msvar addTwoNumbers = function(l1, l2) &#123; const toArray = list =&gt; &#123; const arr = []; const search = node =&gt; &#123; arr.push(node.val) return node.next != null ? search(node.next) : '' &#125; search(list) return arr; &#125; const arr1 = toArray(l1); const arr2 = toArray(l2); const large = (arr1.length &gt;= arr2.length ? arr1 : arr2); const small = (arr1.length &gt;= arr2.length ? arr2 : arr1); const l = large.length; const newArr = new Array(l).fill(0); const splice = idx =&gt; &#123; if(newArr[idx + 1] == null) &#123; newArr.push(1); &#125; else &#123; if(newArr[idx + 1] === 9) &#123; newArr[idx + 1] = 0; splice(idx + 1) &#125; else &#123; newArr[idx + 1]++; &#125; &#125; &#125; for(let i = 0; i &lt; l; i++) &#123; if(small[i] == null) &#123; const result = newArr[i] + large[i]; if(result &gt;= 10) &#123; splice(i) newArr[i] = result - 10; &#125; else &#123; newArr[i] = result; &#125; &#125; else &#123; const result = large[i] + small[i]; if(result &gt;= 10 || newArr[i] + result &gt;= 10) &#123; splice(i) newArr[i] = newArr[i] + (result - 10); &#125; else &#123; newArr[i] = newArr[i] + result; &#125; &#125; &#125; return newArr;&#125;;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://chiabi.github.io/categories/Algorithm/"}],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://chiabi.github.io/tags/algorithm/"},{"name":"leetcode","slug":"leetcode","permalink":"http://chiabi.github.io/tags/leetcode/"}]},{"title":"TIL","slug":"TIL","date":"2018-06-12T12:40:48.000Z","updated":"2018-06-12T16:25:45.759Z","comments":true,"path":"2018/06/12/TIL/","link":"","permalink":"http://chiabi.github.io/2018/06/12/TIL/","excerpt":"","text":"오늘 한 일1. 프론트엔드 개발 과정 - 리액트 실습수업시간 대부분이 실습 시간이었는데 덕분에 조금 리액트 state와 props, Component같은 기본 사용법은 익숙해지는 것 같다. 빨리 숙지해서 Redux같은 심화 부분을 들을때 어려움이 없도록 많이 연습해야겠다. 2. Algorithm 문제 풀이저번 풀이는 연결 리스트에 대해 이해가 없어서 오래 걸렸다. 몇번 실행 오류 나보면서 이해하게 되었지만, 나중에 따로 정리해봐야겠다. 다른 식으로 풀어봤는데, 다행히도 저번에 푼 것보다는 효율적인 코드인 것 같다. 시간이 단축되었다. 다른 방법 딱 한번만 더 생각해보고 다른 사람 풀이 보면서 포스팅을 다시 추가해야겠다. 앞으로 할 일 React 캘린더 완성하기 RGB 챌린지 React로 구현해보기 알고리즘 Add Two Numbers 다시 풀어보고 다른 사람 풀이 정리하기(데이터 구조 - 연결리스트 정리하자)","categories":[{"name":"TIL","slug":"TIL","permalink":"http://chiabi.github.io/categories/TIL/"}],"tags":[{"name":"TIL","slug":"TIL","permalink":"http://chiabi.github.io/tags/TIL/"}]},{"title":"leetcode - Reverse Integer","slug":"revese-integer","date":"2018-06-11T11:34:55.000Z","updated":"2018-06-14T19:03:56.511Z","comments":true,"path":"2018/06/11/revese-integer/","link":"","permalink":"http://chiabi.github.io/2018/06/11/revese-integer/","excerpt":"","text":"leetcode 문제링크 Given a 32-bit signed integer, reverse digits of an integer. Example 1: Input: 123 Output: 321 Example 2: Input: -123 Output: -321 Example 3: Input: 120 Output: 21 Note:Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−231, 231 − 1]. For the purpose of this problem, assume that your function returns 0 when the reversed integer overflows. 나의 풀이123456// Runtime: 80 msvar reverse = function(x) &#123; const range = 2 ** 31; const result = parseInt(x.toString().split('').reverse().join('')); return (result &gt; (range - 1)) ? 0 : x &gt;= 0 ? result : result * -1;&#125;; 코드가 짧아보인다고 빠른게 아닌 것임을…Big O Notation을 아직 제대로 이해하지 못했지만 제아무리 코드상 짧아보여도 반드시 좋은 코드인 것은 아니란 걸 알았다.(그리고 나의 코드가 그런듯…) range = 2 ** 31은 Math.pow(2, 31)로 구해도 될 것 같고 숫자를 문자열 화하는 방법은 다양하다. (&#39;&#39; + x, ${x}, x.toString()…) 문제 자체가 풀기에는(정말 푼 것에만 의미를 두자면) 크게 어렵지 않았고, 나는 숫자를 reverse한다고 해서 당연히 1문자열로 만들어서, 2배열화해서, 3reverse메소드로 뒤집고 다시 4join메소드로 합쳐준 다음 5숫자화하면 되는 것 아닌가?라고 생각했다.그리고 이게 거의 공식처럼 머릿속에 있었는데, 다른 사람들 풀이를 보니까 생각이 넓어지는 기분이다. 다른 사람 풀이12345678910111213141516171819202122// 64msvar reverse = function(x) &#123; var isNeg = x &lt; 0; var result = 0; x = Math.abs(x); while(x) &#123; var lastDigit = x % 10; // 33 % 10 = 3 result *= 10; // 0 result += lastDigit; // 3 x = parseInt(x / 10); // 3 &#125; result = isNeg ? -result : result; if(result &gt; Math.pow(2, 31) - 1 || result &lt; -Math.pow(2, 31)) &#123; return 0; &#125; return result;&#125;; 이 풀이는 먼저 음수인지 여부를 저장해둔다. x를 Math.abs()를 통해 절대값으로 만든다. 만약 그 전에 result에 저장된 값이 있으면 10을 곱해줘서 자리수를 올린다. x를 10으로 나눈 나머지를 result에 더해준다. x에는 다시 10으로 나눈 정수값만 저장하면서 x가 0이 될때까지 반복한다. 이렇게 reverse한 수가 음수인지 여부에 따라 다시 음수화시켜주고 만약 제한범위를 넘어서면([−231, 231 − 1]) 0을 반환하고 아니면 result를 그대로 반환한다. 위의 풀이와 비슷한데 조금 다른 풀이123456789101112131415161718// 68msvar reverse = function(x) &#123; var MAX = Math.pow(2, 31) - 1; var number = 0, symbol = 1; if(x &lt; 0)&#123; x = Math.abs(x); symbol = -1; &#125; while(x &gt; 0)&#123; number = number * 10 + x % 10; x = Math.floor(x / 10); &#125; return number &gt; MAX ? 0 : symbol * number;&#125;; 1234567891011// 76msconst reverse = function(x) &#123; if (x==0) return 0 let isPositive = x &gt; 0 let digits = (isPositive)? x.toString().split(\"\").reverse() : (-x).toString().split(\"\").reverse() let num = parseInt(digits.join(''), 10) if (num &gt;= 2147483647) return 0 return num * (isPositive? 1: -1)&#125;; 이 풀이는 나의 경우 Math.pow(2, 31)내지는 2 ** 31로 구하도록 했는데 이미 구해진 값을 넣어서 연산을 하나 줄였다. 대체로 while문을 통해서 10을 이용한 연산을 통해 자리수를 바꿔주는 방법이 문자열 → 배열 → reverse로 하는 방법보다 빠른 것 같다.","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://chiabi.github.io/categories/Algorithm/"}],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://chiabi.github.io/tags/algorithm/"},{"name":"leetcode","slug":"leetcode","permalink":"http://chiabi.github.io/tags/leetcode/"}]},{"title":"자바스크립트 모듈","slug":"modules","date":"2018-06-11T08:35:52.000Z","updated":"2018-06-11T11:47:51.497Z","comments":true,"path":"2018/06/11/modules/","link":"","permalink":"http://chiabi.github.io/2018/06/11/modules/","excerpt":"","text":"패스트 캠퍼스 프론트엔드 개발 스쿨에서 배운 내용을 정리합니다.내용에 오류가 있다면 댓글 남겨주시기 바랍니다. 모듈큰 규모의 프로젝트에서 JavaScript 코드를 여러 파일과 폴더에 나누어 작성하고, 충돌하지 않게 서로가 서로를 효율적으로 불러올 수 있도록 해주는 시스템이 필요해졌다. ES2015 모듈: script태그에 type=&quot;module&quot; 어트리뷰트 추가12&lt;!-- 모듈로서 동작한다, 파일 확장자는 대개 .mjs --&gt;&lt;script type=\"module\" src=\"index.mjs\"&gt;&lt;/script&gt; 단, 다음과 같은 이유로 아직 브라우저에 내장된 모듈 기능을 사용하는 경우가 별로 없다. 이전까지의 JavaScript 파일의 동작방식과 다른 동작방식을 가지고 있다. 모듈이 제대로 동작하기 위해 몇가지 조건을 충족시켜야 한다. 구형 브라우저는 모듈을 지원하지 않는다. 대신 Webpack, Parcel 등의 모듈번들러를 통해 변환과정을 거친 뒤, 브라우저에서 일반적인 JavaScript파일로 불러오는 방법이 널리 사용되고 있는 추세이다. 모듈 번들러는 여러 자바스크립트 파일을 설정에 따라 하나 이상의 파일로 합쳐주는 프로그램이다. 최신문법을 트랜스파일링 해주는 기능까지 갖추고 있다. 모듈 번들러들은 파일간 관계를(의존성) 분석해서 모듈을 하나로 합쳐줄 때 사용하는 방식이 각자 다르다. Webpack은 import를 통해 분석한다. Parcel은 html 태그를 보고도 분석한다.(html 안에 link태그 쓰고, scss를 불러오는 식으로 쓸 수 있다.) 1. 모듈이란?ES2015 모듈: JavaScript코드를 담고 있는 파일 import 혹은 export구문을 사용할 수 있다. 기본으로 엄격모드로 동작한다. 모듈 파일의 가장 바깥쪽에서 선언된 이름은 전역 스코프가 아니라 모듈 스코프에서 선언된다. 2. 모듈 스코프12345// variables.jsvar foo = 'bar';// 이 파일이 모듈로서 사용되고 있다면, `undefined`가 출력된다.console.log(window.foo); 이 모듈스코프는 모듈 파일마다 개별적으로 존재한다. 따라서 여러 모듈의 가장 바깥쪽에서 같은 이름으로 변수, 함수, 클래스를 선언하더라도,서로 다른 스코프에서 선언되기 때문에 이름의 충돌이 생길 일이 없다. 3. export &amp; import값이 아니라 이름이 export되는 것 모듈 스코프에서 정의된 이름은 export 구문을 통해 다른 파일에서 사용할 수 있다. variables.js 1234const foo = 'bar';const spam = 'eggs';export &#123;foo, spam&#125;; functions.js 12345import &#123;foo, spam&#125; from './variables.js';console.log(foo);console.log(spam);` 함수나 클래스도 export를 통해 여러 모듈에서 재사용할 수 있다. 12345678function add(x, y) &#123; return x + y;&#125;class Person &#123; // ...&#125;export &#123; add, Person &#125;; 다른 모듈에 있는 이름을 사용하려면, 반드시 모듈에서 이름을 export 해주어야 한다.모듈 실행환경에 따라 에러나, 이름에 undefined가 들어가는 식으로 의도치 않게 동작한다. 4. 선언과 동시에 export 하기이름을 선언하는 구문 앞에 export를 붙여주면, 선언과 export를 한꺼번에 할 수 있다.1234567export const foo = 'bar';export function add(x, y) &#123; return x + y;&#125;export class Person &#123; // ...&#125; 5. default export모듈을 대표하는 하나의 값을 지정하고, 그 값을 다른 모듈에서 편하게 불러와서 사용할 수 있다.이렇게 사용하는 값을 default export라고 부른다. foo.js 1export default 'bar'; main.js 1234// 중괄호를 생략하면, 모듈의 default export를 가져온다.import foo from './foo.js'console.log(foo); // bar ※ 모듈당 하나의 default export밖에 허용되지 않는다.모듈에는 하나의 default export와 여러개의 named export(일반적인 export)를 지정할 수 있다. import 구문에서 default export와 일반적인 export를 동시에 가져올 수 있다.12 // node_modules에 설치된 것은 따로 path없이 불러오면 됨import React, &#123;Component, Fragament&#125; from 'react'; 123export default class React &#123;&#125;export class Componet &#123; /*...*/ &#125;export class Fragment &#123; /*...*/ &#125; 6. 다름 이름으로 export &amp; import 하기export혹은 import 하는 이름의 뒤에 as를 붙여 다른 이름이 대신 사용되게 할 수 있다. export 이름 뒤에 as foo.js 12const foo = 'bar';export &#123;foo as FOO&#125;; main.js 1import &#123;FOO&#125; from './foo.js' import 이름 뒤에 as foo.js 12const foo = 'bar';export foo; main.js 12import &#123;foo as FOO&#125; from './foo.js'console.log(FOO) 7. 모듈 사용 시 주의할 점모듈 번들러는 import를 하지 않으면 아예 JavaScript코드를 실행시키지 않는다.모듈간의 의존관계를 다 파악한 뒤 필요한 것만 실행시킨다. log.js12console.log('log~~~~~')export const foo = bar; main.js123import &#123;foo&#125; from './log'// log~~~~가 콘솔에 출력된다. 만약 다른 모듈에서도 ‘log.js’를 import 하더라도 ‘log~~~~’는 한번만 출력된다.이는 import구문이 코드를 실행시키라는 명령이 아니기 때문이다.export와 import 구문은 단지 모듈간의 의존관계를 나타내는 것일 뿐이다. ECMAScript 공식 명세에는 모듈을 불러오는 방법에 대한 내용이 포함되어 있지 않다.모듈번들러, 브라우저마다 모듈을 불러오는 방법이나 구체적인 동작 방식은 다를 수 있다. 8. ES2015 이전의 모듈들ES2015 모듈 이전에 CommonJS, AMD 등의 모듈 시스템이 있었다. 123456// Node.js에서 쓰는 모듈 객체const os = require('os')module.export = &#123; a: a b: b&#125;","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://chiabi.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://chiabi.github.io/tags/JavaScript/"},{"name":"ES6","slug":"ES6","permalink":"http://chiabi.github.io/tags/ES6/"}]},{"title":"try...catch, 자바스크립트에서의 예외 처리","slug":"try-catch","date":"2018-06-11T08:35:41.000Z","updated":"2018-06-11T11:47:59.572Z","comments":true,"path":"2018/06/11/try-catch/","link":"","permalink":"http://chiabi.github.io/2018/06/11/try-catch/","excerpt":"","text":"패스트 캠퍼스 프론트엔드 개발 스쿨에서 배운 내용을 정리합니다.내용에 오류가 있다면 댓글 남겨주시기 바랍니다. 예외처리프로그램의 언어들이 항상 완벽하게 동작하지는 않는다.단순 버그이거나, 프로그래머가 잘못 작성했거나, 프로그래밍 언어 자체가 에러를 내는 경우가 있다. 1. 동기식 코드에서의 예외 처리프론트엔드 개발자의 실수1new Array(-1) // RangeError: Invalid array length 1console.log(foo) // ReferenceError: foo is not defined 프론트엔드 개발자의 의도와 다른 실수12fetch('https://nonexistent-domain.nowhere'); // TypeError: Failed to fetch// 위 주소는 맞는데 서버/네트워크 쪽 에러가 있다거나 에러가 발생하면 나머지 로직이 실행되지 않는다. 그 시점에 실행 중이었던 작업을 완료할 수 없게 된다.123console.log('에러가 나기 직전까지의 코드는 잘 실행됩니다.');new Array(-1); // RangeError: Invalid array lengthconsole.log('에러가 난 이후의 코드는 실행되지 않습니다.'); // 이것은 실행되지 않는다. 위와 같이 코드의 실행이 중단된다. try...catch...finally 구문을 사용하면 에러가 나더라도 코드의 실행을 지속할 수 있다. 12345678910try &#123; // 여기서 에러가 나면 에러가 난 시점에 코드의 흐름이 // catch로 넘어간다. console.log('에러가 나기 직전까지의 코드는 잘 실행됩니다.'); new Array(-1); // RangeError: Invalid array length console.log('에러가 난 이후의 코드는 실행되지 않습니다.');&#125; catch (e) &#123; console.log('코드의 실행 흐름이 catch 블록으로 옮겨집니다.'); alert(`다음과 같은 에러가 발생했습니다: $&#123;e.name&#125;: $&#123;e.message&#125;`);&#125; try: 에러가 났을 때 원상복구를 시도할 코드. 에러 발생시 코드의 실행 흐름이 catch 블록으로 옮겨간다. catch: 에러에 대한 정보를 담고 있는 객체(위 예제의 e)를 사용할 수 있다. e.name: RangeError같은 에러의 이름 e.meassage: Invalid array length 에러 메시지 12345678910111213try &#123; console.log('에러가 나기 직전까지의 코드는 잘 실행됩니다.'); /* new Array(-1); */ console.log(foo); console.log('에러가 난 이후의 코드는 실행되지 않습니다.');&#125; catch (e) &#123; if(e.name === 'RangeError') &#123; alert(`배열 생성자에 잘못된 인수가 입력되었습니다.`) &#125; else if (e.name === `ReferenceError`) &#123; alert(`선언되지 않은 변수가 사용되고 있습니다.`) &#125; console.log('코드의 실행 흐름이 catch 블록으로 옮겨집니다.');&#125; finally: try블록 안에서의 에러 발생 여부와 관계 없이 무조건 실행되어야 하는 코드return, break, continue등으로 코드의 실행 흐름이 즉시 이동되더라도 실행된다. 123456789for (let i of [1, 2, 3]) &#123; try &#123; if (i === 3) &#123; break; &#125; &#125; finally &#123; console.log(`현재 i의 값: $&#123;i&#125;`); &#125;&#125; finally블록은 catch 블록과도 같이 사용된다. 에러가 안 났을 때: try - finally 에러가 났을 때: try - 에러발생 - catch - finally 1-1. 직접 에러 발생시키기코드를 다른 사람이나 미래의 내가 의도한 대로 사용하지 않을 경우 에러가 발생하도록 할 수 있다. Error생성자, throw구문123456const even = parseInt(prompt('짝수를 입력하세요'));if (even % 2 !== 0) &#123; throw new Error('짝수가 아닙니다.');&#125;// 3을 입력할 경우// Error: 짝수가 아닙니다. 123456789throw 'ggg';// 던지는 것에 제한이 없으나throw new Error('ddd')// 반드시 에러 객체를 던져야 한다.const e = new Error('짝수가 아니다')// Error는 어디서나 쓸 수 있는 객체(생성자)이다.e;// Error: 짝수가 아니다. 다음과 같이 내가 에러를 만들어 던질 수 있고, 이를 try...catch 구문으로 잡을 수 있다.12345678try &#123; const even = parseInt(prompt('짝수를 입력하세요')); if (even % 2 !== 0) &#123; throw new Error('짝수가 아닙니다.'); &#125;&#125; catch (e) &#123; alert(e.message);&#125; 복잡한 프로그램을 짜다보면 추가적인 자세한 정보를 추가해서 에러를 만들고 싶게 된다.에러의 종류를 구분해야 하거나 에러 객체에 기능을 추가해야 할 필요가 있다. 그냥 내장 에러 생성자가 아니라 내가 자체 Error 클래스를 만들경우 다음과 같은 방법이 있다.123456789101112131415161718class MyError extends Error &#123; constructor(value, ...params) &#123; super(...params); this.value = value; this.name = 'MyError'; &#125;&#125;try &#123; const even = parseInt(prompt('짝수를 입력하세요')); if (even % 2 !== 0) &#123; throw new MyError(even, '짝수가 아닙니다.'); &#125;&#125; catch (e) &#123; if (e instanceof MyError) &#123; console.log(`$&#123;e.name&#125;: $&#123;e.value&#125; 는 $&#123;e.message&#125;`); &#125;&#125; 에러에서도 동기식 처리와 비동기식 처리가 있다. 2. 비동기식 코드에서의 예외 처리2-1. 비동기 콜백비동기식으로 작동하는 콜백의 내부에서 발생한 에러는, 콜백 바깥에 있는 try 블록으로는 잡아낼 수 없다.12345678910try &#123; setTimeout(() =&gt; &#123; // 비동기 코드 안의 에러는 잡히지 않는다. throw new Error('에러!'); &#125;);&#125; catch (e) &#123; console.error(e);&#125;// Uncaught Error: 에러!// 에러가 잡히지 않아서 생기는 에러;; JavaScript 엔진은 에러가 발생하는 순간 호출 스택을 되감는 과정을 거친다.이 과정 중에 try 블록을 만나야 코드의 실행 흐름을 원상복구시킬 수 있다. 에러는 호출스택과 관련되어 있다. 아래는 동기식 예외 발생123456789101112131415161718192021222324function add(x, y) &#123; // 에러를 이곳에서 발생시키고 new Array(-1); return x + y;&#125;function add2(x) &#123; return add(x, 2);&#125;function add2AndPrint(x) &#123; // try... catch 구문이 여기있지만 // 자바스크립트 실행 엔진이 에러가 발생하면 호출 스택을 하나씩 지워가면서 // try가 있는지 찾아본다. try &#123; // 여기서 add2를 호출하고 add2는 add를 호출하기 때문에 에러가 잡힌다. const result = add2(x); console.log(result); &#125; catch(e) &#123; alert('잡았다!'); &#125;&#125;add2AndPrint(3); // alert으로 '잡았다!'가 뜬다. 12345678910111213141516171819202122232425function add(x, y) &#123; // 에러를 이곳에서 발생시키고 new Array(-1); return x + y;&#125;function add2(x) &#123; // 호출스택을 되감다 가장 먼저 만나는 try에서 에러가 잡힌다. try &#123; return add(x, 2); &#125; catch(e) &#123; alert('add2에서 잡히나?') &#125;&#125;function add2AndPrint(x) &#123; try &#123; const result = add2(x); console.log(result); &#125; catch(e) &#123; alert('잡았다!'); &#125;&#125;add2AndPrint(3); // alert으로 'add2에서 잡히나?'가 뜬다. 비동기 콜백이라면 단순 try...catch 구문으로는 잡을 수 없다.비동기 콜백이 실행될 때는 이미 호출스택이 비워져 try를 찾을 수 없다.12345678910111213141516171819202122232425262728function add(x, y) &#123; setTimeout(() =&gt; &#123; // 이 콜백이 일단 태스크큐에 들어갔다가 호출 스택이 비워지면 실행된다. // 호출스택을 되감아 가면서 try를 찾아야하는데 // 이 콜백이 실행될 때는 이미 호출스택이 비워졌으므로 try를 찾을 수 없다. new Array(-1); &#125;) return x + y;&#125;function add2(x) &#123; try &#123; return add(x, 2); &#125; catch(e) &#123; alert('add2에서 잡히나?') &#125;&#125;function add2AndPrint(x) &#123; try &#123; const result = add2(x); console.log(result); &#125; catch(e) &#123; alert('잡았다!'); &#125;&#125;add2AndPrint(3); 따라서, 비동기 콜백 내부에 try를 작성해주어야 한다. 이벤트 리스너와 try catch 블록 예제1234567891011121314const buttonEl = document.querySelector('button');try &#123; buttonEl.addEventListener('click', e =&gt; &#123; try &#123; new Array(-1); alert('버튼이 눌렸습니다.'); &#125; catch (e) &#123; alert('이벤트 리스너 안에서 에러가 발생했습니다.'); &#125; &#125;) &#125; catch (e) &#123; alert('에러가 발생했습니다.'); // 출력되지 않음&#125; 2-2. PomisePromise 객체는 세 가지 상태를 가질 수 있다. pending - Promise 객체에 결과값이 채워지지 않은 상태 fulfilled - Promise 객체에 결과값이 채워진 상태(이때 then메소드 또는 await를 통해 무언가를 실행했다.) rejected - Promise 객체에 결과값을 채우려고 시도하다가 에러가 난 상태 then메소드에 첫 번째 인수로 넘겨준 콜백이 실행되지 않고, 두 번째 인수로 넘겨준 콜백이 실행된다. 그리고 이 콜백에는 에러 객체가 첫번째 인수로 주어진다. 1234567891011121314151617const p = new Promise(resolve =&gt; &#123; const even = parseInt(prompt('짝수를 입력하세요')); if (even % 2 !== 0) &#123; throw new Error('짝수가 아닙니다.'); &#125; else &#123; // 짝수면 fullfiled되어 then메소드의 첫번째 인수로 들어간 함수가 실행 resolve(even); &#125;&#125;);// then 콜백에서 반환된 값이 다음Promise의 값이 된다.p.then(even =&gt; &#123; return '짝수입니다.';&#125;, e =&gt; &#123; return e.message;&#125;).then(alert);// .then(msg =&gt; alert(msg))와 같음 Promise가 rejected 상태가 되었을 때 catch 메소드를 통해 다음과 같은 방법으로도 에러 처리 콜백을 지정해 줄 수 있다.12345p.then(even =&gt; &#123; return '짝수입니다.';&#125;).catch(e =&gt; &#123; return e.message;&#125;).then(alert); 2-3. 비동기 함수비동기 코드에서의 try...catch와 비동기 함수에서의 try...catch는 다르게 동작한다. (내부 동작 방식이 완전히 다르다. - 비동기 함수를 사용하면 예외처리도 보다 편하게 할 수 있다.) 비동기 함수 내부에서는, rejected 상태가 된 Promise객체를 동기식 예외처리 방식과 동일하게 try...catch...finally 구문으로 처리할 수 있다.1234567891011async function func() &#123; try &#123; // ※ 단, Promise 객체에 대해 await 구문을 사용해야만 // 에러가 발생했을 때 catch 블록으로 코드의 실행 흐름이 이동한다. const res = await fetch('https://nonexistent-domain.nowhere'); &#125; catch (e) &#123; console.log(e.message); &#125;&#125;func(); // 출력 결과: Failed to fetch","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://chiabi.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://chiabi.github.io/tags/JavaScript/"},{"name":"ES6","slug":"ES6","permalink":"http://chiabi.github.io/tags/ES6/"}]},{"title":"TIL 20180611","slug":"TIL-1","date":"2018-06-11T08:35:06.000Z","updated":"2018-06-11T13:32:53.094Z","comments":true,"path":"2018/06/11/TIL-1/","link":"","permalink":"http://chiabi.github.io/2018/06/11/TIL-1/","excerpt":"","text":"오늘 한 일1. 프론트엔드 개발 스쿨 과정오늘은 예외 처리(try...catch)와 모듈부분 진도를 나가고 리액트 실습(todoList)을 했다. 예외 처리 부분은 중간프로젝트 하면서 미리 읽어봤었는데, 호출스택과 태스크 큐에서의 코드 동작원리까지 같이 설명해주시니 좀 더 깊이있게 이해되는 것 같다. 리액트 컴포넌트 간의 변경사항 공유 때문에 조상 컴포넌트에서 상태를 관리하니까 컴포넌트를 나눌때마다 상태도 내려보내줘야해서 헷갈린다.아직까지 배운 내용에서는 내가 중간 프로젝트때 가장 하위의 template에 여러 정보를 담은 객체를 상위 template으로부터 내려보내느라 그 사이의 하위 template에도 똑같이 그 객체를 내려보내줬던 방식과 크게 다르지 않은 것 같다.Redux나 Context를 통해서 이런 부분을 효율적으로 관리할 수 있다는데, 어떤식으로 만들었길래 그게 가능할까 신기하다. 강사님과 실습 시간에 어떤 메소드는 하위 컴포넌트에서 작성하고 어떤 메소드는 상태를 관리하고 있는 App 컴포넌트에 작성했다. 그러면서 역할과 책임에 대한 말씀을 해주셨다.역할과 책임을 어떻게 정해야할지는 프로젝트를 진행할때마다 어렵게 느껴진다. 정답이 있는 건 아닌것 같은데 어떻게 코드를 짜야 역할과 책임에 맞게 코드를 작성하게 되는 건지 아직은 감이 잡히지 않아서 많이 만들어봐야겠다. 2. Algorithm 문제 풀이다른 사람들 풀이를 보니까 숫자를 거꾸로 만드는 방법에 대해서 다른 방법을 알게 되었다. 어제 풀었지만 차마 포스팅할 수 없는 부끄러운 풀이라 좀 더 다듬으면 포스팅하자고 미뤄둔 문제도 숫자를 문자열화하는 식으로 풀었는데, 이번 문제를 좀 더 응용하면 새로운 방식으로 풀 수 있을 것 같다. 3. React 캘린더 만들기moment.js를 사용하고 있는데, 캘린더의 body 부분의 표를 짜는 것만 구하면 수월할 것 같은데, 아직 못 만들었다. 하지만 어젯밤에 자기 전에 생각해본 것을 좀 더 수정해보면 될 것 같다. 앞으로 할 일 React 캘린더 완성하기 JSX 공부하기","categories":[{"name":"TIL","slug":"TIL","permalink":"http://chiabi.github.io/categories/TIL/"}],"tags":[{"name":"TIL","slug":"TIL","permalink":"http://chiabi.github.io/tags/TIL/"}]},{"title":"TIL 20180610","slug":"TIL","date":"2018-06-10T15:03:46.000Z","updated":"2018-06-10T17:19:14.892Z","comments":true,"path":"2018/06/11/TIL/","link":"","permalink":"http://chiabi.github.io/2018/06/11/TIL/","excerpt":"","text":"오늘 한 일1. 리액트 캘린더 프로젝트리액트 연습삼아 리액트로 jQuery의 Datepicker같은 캘린더를 만들고 있다.연습으로 만들어보는 건데 나에게 좀 어려운 것 같다. 리액트 문서도 다시 찾아보면서 하고 있다. 생각보다 한 것이 없는데 하루가 금방 지나가버려서 마음이 조급해진다. 좀더 시간을 잘 쪼개서 써야겠다. 앞으로 할 일 React 캘린더 완성하기","categories":[{"name":"TIL","slug":"TIL","permalink":"http://chiabi.github.io/categories/TIL/"}],"tags":[{"name":"TIL","slug":"TIL","permalink":"http://chiabi.github.io/tags/TIL/"}]},{"title":"스캐폴딩, CRUD, 퍼머링크","slug":"DG_scaffolding","date":"2018-06-08T15:00:00.000Z","updated":"2018-08-04T15:21:10.457Z","comments":true,"path":"2018/06/09/DG_scaffolding/","link":"","permalink":"http://chiabi.github.io/2018/06/09/DG_scaffolding/","excerpt":"","text":"hexo로 블로그 만들면서 모르는 용어를 정리했다. 1. 스캐폴딩(scaffolding)건축용어로 비계라는 의미인데, 작업을 위해 임시로 설치한 가설 발판이나 가설 구조물을 말한다.프로그래밍 쪽에서는 데이터베이스의 각 테이블에 대한 웹 페이지를 자동으로 생성하는 Dynamic Data 요소를 말한다. 이렇게 자동 생성된 웹 페이지를 통해 각 테이블에 대해 만들기, 읽기, 업데이트 및 삭제(CRUD) 작업을 수행할 수 있다. 스캐폴딩을 구성하는 템플릿을 사용해 효율적인 데이터 기반 웹 사이트를 신속하게 작성할 수 있다.개발 중인 코드가 제 모습을 가지기 전까지 임시 스캐폴딩 코드를 코드 구조를 잡는데 사용한다고 한다. 정리하면 웹 개발 프레임워크(ASP.NET이나 Ruby on Rails등)에서 단순한 CRUD 서비스 프로세스를 구축하도록 지원하는 템플릿 개념인 것 같다. 참고 ASP.NET Dynamic Data 스캐폴딩 Ruby on Rails - 스캐폴딩 2. CRUDCreate, Read, Update, Delete대부분의 컴퓨터 소프트웨어가 가지는 기본적인 데이터 처리 기능을 묶어서 일컫는 말.사용자 인터페이스가 갖추어야 할 기능(정보의 참조/검색/갱신)을 가리키는 용어로서도 사용된다. 참고 [위키백과] - CRUD 3. 퍼머링크(permalink)인터넷에서 특정 페이지에 영구적으로 할당된 URL 주소를 뜻한다.영구적인 주소라는 뜻인데 한국에서는 고유 링크, 고유 주소라는 명칭으로 광범위하게 퍼져있다. 퍼머링크를 사용하는 대표적인 사례는 블로그.시간이 지남에 따라 새로운 내용이 추가되면서 블로그 글의 위치가 쉽게 변하므로, 각각의 글에 영원히 고정된 주소를 제공하는 것이라고 위키백과에 정의되어 있다. hexo에서는 _config.yml 파일이나 font-matter(파일 시작 시 작성하는 YAML, JSON 구역 - 게시물에 대한 환경설정을 하는 곳)에 각 포스트의 permalink의 형식을 지정할 수 있게 한다. hexo 설치시 처음 _config.yml에는 아래와 같이 되어있는데1permalink: :year/:month/:day/:title/ 결과는 2018/06/09/hello-world로 나온다. 참고 [위키백과] 퍼머링크","categories":[{"name":"Dev Glossary","slug":"Dev-Glossary","permalink":"http://chiabi.github.io/categories/Dev-Glossary/"}],"tags":[{"name":"glossary","slug":"glossary","permalink":"http://chiabi.github.io/tags/glossary/"}]},{"title":"TIL 20180609","slug":"20180609-TIL","date":"2018-06-08T15:00:00.000Z","updated":"2018-08-04T15:21:12.149Z","comments":true,"path":"2018/06/09/20180609-TIL/","link":"","permalink":"http://chiabi.github.io/2018/06/09/20180609-TIL/","excerpt":"","text":"오늘 한 일1. hexo로 블로그를 만들었다.금요일, 소프트웨어 공학 특강시간에 최우영 강사님이 보여주신 초보몽키의 개발공부로그라는 블로그에 감명받아 당장 블로그를 만들었다. 사실 그전에도 알고리즘 퀴즈 관련해서 구글에서 검색하면 거의 매번 보이던 블로그였는데, 학원 수강생이었다는 거에 충격이랄지 나도 저렇게 열심히 살아야겠다는 자극을 받았다. hexo + icarus 테마 + github page로 블로그를 만들었다.어느정도 파악해보려고 열어봤더니 EJS와 Stylus의 조합이라 당황스러웠다.처음에는 체감상 Jekyll보다 어렵게 느껴졌는데(Jekyll 테마는 Sass였다.) 보다보니 익숙해지는 것 같다. 스타일은 아직 수정한 것이 없는데, 테마 자체의 디자인도 마음에 들지만 천천히 바꿔봐야겠다.예를들면 모바일에서는 헤더를 상단에 픽스시킨다든지 정도의 커스터마이징은 필요해보인다. 만드는 것도 파악하는 것도 오래 걸려서, 저번 Jekyll 블로그처럼 학원 과정 끝나고 시간이 남으면 만들까 생각도 했는데, 일단 만들어놓고 천천히 바꾸자는 생각으로 만들었더니 하길 잘했다는 생각이 든다. github와 다르게 좀 더 글이 정제되어 보인다. 프로필 일러스트도 하는김에 만들었다.(이놈의 디자인 욕심…) 마침 github가 로키(턱시도 고양이)여서 로키 일러스트를 만들었다. 생각보다 금방 구상하고 오랜만에 일러 만지느라 헤맨 것 치고는 시간도 얼마 소요되지 않았다.(다행이다. 오래걸렸으면 자괴감이 들었을지도…) 지난 TIL과 알고리즘 풀이는 블로그로 옮길지, 아니면 기존 github 레포지토리로 남길지는 생각해봐야겠다. 2. 스캐폴딩, 퍼머링크 등 모르는 용어를 정리했다.hexo로 블로그를 만들려다 보니 모르는 용어가 많았다.스캐폴딩, CRUD, 퍼머링크를 정리하는 것으로 첫 포스팅을 하기로 했다. 대부분 데이터베이스나 서버 개발 쪽 아니면 아키텍처 관련 용어인듯하다. 데이터베이스 쪽도 생활코딩같은 강의를 통해서 틈틈이 공부해야겠다. 모르는 용어가 점점 줄어들었으면 좋겠다. (하지만 또 새로운 게 생겨나겠지…) 앞으로 할 일 React로 간단한 미니 프로젝트 만들기(학원내 스터디) JSX 공부하기 모르는 게 많으니까 해야겠다 하는 것도 점점 많아진다. 그리고 알면 알수록 부족함이 보여서 더더욱 심해지는 것 같다. 이럴때일수록 무엇을 먼저 할지 우선 순위를 빠르게 정하고 밀고 나가야겠다. 블로그 만들면서 오랜만에 나를 프론트엔드 개발의 길로 이끈 블로그에 들어갔다. HyunSeob이라는 분의 블로그인데, hexo로 만들었다는 포스팅을 봤던 기억이 나서 다시 찾아봤다. (오랜만에 읽어보다 이 마음에 드는 테마도 건졌다.)그 당시 gulp로 Sass를 써보다가 Webpack을 사용해보자면서 검색하다 보게 된 블로그였다. 포스팅이 엄청 많은 것은 아니지만, 1년 안에 포스팅한 내용이 Node.js, Webpack, AngularJS, CoffeScript, TypeScript등이어서 적잖게 충격을 받았다.이렇게 열심히 트랜드를 쫓아가는구나, 나도 머물러 있으면 안 되겠다는 자극을 받았다. 그때의 마음을 항상 잊지 않으려한다. 지치지 않고 계속 달릴 수 있으면 좋겠다.","categories":[{"name":"TIL","slug":"TIL","permalink":"http://chiabi.github.io/categories/TIL/"}],"tags":[{"name":"TIL","slug":"TIL","permalink":"http://chiabi.github.io/tags/TIL/"}]}]}