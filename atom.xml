<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Chiabi&#39;s dev blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://chiabi.github.io/"/>
  <updated>2018-07-23T14:57:53.305Z</updated>
  <id>http://chiabi.github.io/</id>
  
  <author>
    <name>chiabi</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>TIL</title>
    <link href="http://chiabi.github.io/2018/07/23/TIL/"/>
    <id>http://chiabi.github.io/2018/07/23/TIL/</id>
    <published>2018-07-23T14:10:16.000Z</published>
    <updated>2018-07-23T14:57:53.305Z</updated>
    
    <content type="html"><![CDATA[<h2 id="오늘-한-일"><a href="#오늘-한-일" class="headerlink" title="오늘 한 일"></a>오늘 한 일</h2><h3 id="퍼블리싱-외주-80-진행"><a href="#퍼블리싱-외주-80-진행" class="headerlink" title="퍼블리싱 외주(80% 진행)"></a>퍼블리싱 외주(80% 진행)</h3><p>디자인 시안의 폰트 사이즈가 대부분 10px이하다. 어떤 버튼은 폰트 사이즈가 7px이다. 아이패드에서는 그나마 좀 잘 보이는데, 작업하는 내가 괴로울 정도로 노트북에서는 잘 안보인다.(내가 눈이 나쁜건가…)<br>쇼핑몰 퍼블리싱할 때 받았던 디자인에서는 대부분 기본적인 폰트 사이즈는 12px 혹은 14px이고 제일 작은 폰트 사이즈가 10px이었다. 그리고 그렇게 해야 가독성이 좋았는데, 아이패드나 브라우저에서 화면을 확대하는 방법이 있기 때문에 그렇게 하는 걸까.</p><ul><li><a href="http://koreawebdesign.com/typography-for-webdesign/" target="_blank" rel="noopener">웹디자인을 위한 타이포그라피 10가지 팁</a></li><li><a href="http://webactually.com/2015/10/%EB%B0%98%EC%9D%91%ED%98%95-%EC%9B%B9-%EB%94%94%EC%9E%90%EC%9D%B8%EC%97%90%EC%84%9C-%EA%B8%80%EC%A4%84%EC%9D%98-%EA%B8%B8%EC%9D%B4%EC%99%80-%EA%B8%80%EC%9E%90-%ED%81%AC%EA%B8%B0-%EA%B7%A0%ED%98%95/" target="_blank" rel="noopener">반응형 웹 디자인에서 글줄의 길이와 글자 크기 균형 잡기</a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/font-size-adjust/" target="_blank" rel="noopener">MDN - font-size-adjust</a></li></ul><p>디자인에 range 슬라이더가 있어서 찾아봤는데 rangeslider.js가 제일 복잡한 기능없이 간단하게 사용하기 좋았다.</p><ul><li><a href="http://rangeslider.js.org/" target="_blank" rel="noopener">rangeslider.js</a></li></ul><p>디자인 시안을 어떤 파일로 전달해주면 되냐고해서 포토샵이나 일러면 좋을 것 같다고 했더니 보낸 파일이 전혀 레이어가 분할되어 있지 않았다. sketch로 작업했구나 싶어서 차라리 sketch 파일로 보내달라고 했는데, 재플린으로 공유해달랄 걸 그랬나보다. 하지만 덕분에 윈도우에서 sketch파일을 보는 방법을 찾아보다가 <code>.sketch</code> 파일을 지원하는 Windows app인 <strong>lunacy</strong>라는 걸 찾았다.(무료다!!)<br>그리고 시안 수정은 또 클라이언트 업체의 상주 디자이너가 하는데(시안 자체는 외주), sketch는 안쓰는지 Adobe XD 파일을 보내줬다.<br>포토샵으로만 시안 받아서 퍼블리싱 해봤는데 덕분에 이런 저런 툴을 다양하게 사용해보고 있다.</p><ul><li><a href="https://icons8.com/lunacy" target="_blank" rel="noopener">lunacy</a></li><li><a href="https://www.adobe.com/kr/products/xd.html" target="_blank" rel="noopener">Adobe XD</a></li></ul><h2 id="알고리즘-문제-풀이"><a href="#알고리즘-문제-풀이" class="headerlink" title="알고리즘 문제 풀이"></a>알고리즘 문제 풀이</h2><p>문제가 조금 간단하고 장고걸스 튜토리얼에서 봤던 정도로도 풀 수 있을 것 같아서 파이썬으로도 풀어봤다.<br>range나 len 함수에 대해 찾다가 파이썬 문법을 공부하는데 도움이 될 것 같은 사이트를 찾았다.</p><ul><li><a href="https://wikidocs.net/book/1" target="_blank" rel="noopener">점프 투 파이썬</a></li></ul><hr><p>내일까지면 퍼블리싱 외주 작업은 끝날 것 같다. 그러면 다시 파이널 프로젝트에 집중해서 Context API를 썼던 부분을 리덕스로 변경하는 작업에 착수해야겠다. </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;오늘-한-일&quot;&gt;&lt;a href=&quot;#오늘-한-일&quot; class=&quot;headerlink&quot; title=&quot;오늘 한 일&quot;&gt;&lt;/a&gt;오늘 한 일&lt;/h2&gt;&lt;h3 id=&quot;퍼블리싱-외주-80-진행&quot;&gt;&lt;a href=&quot;#퍼블리싱-외주-80-진행&quot; class=&quot;he
      
    
    </summary>
    
      <category term="TIL" scheme="http://chiabi.github.io/categories/TIL/"/>
    
    
      <category term="TIL" scheme="http://chiabi.github.io/tags/TIL/"/>
    
  </entry>
  
  <entry>
    <title>peakIndexInMountainArray</title>
    <link href="http://chiabi.github.io/2018/07/23/peakIndexInMountainArray/"/>
    <id>http://chiabi.github.io/2018/07/23/peakIndexInMountainArray/</id>
    <published>2018-07-23T13:10:22.000Z</published>
    <updated>2018-07-23T14:06:54.080Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Let’s call an array A a mountain if the following properties hold:</p><p><code>A.length &gt;= 3</code><br>There exists some <code>0 &lt; i &lt; A.length - 1 such that A[0] &lt; A[1] &lt; ... A[i-1] &lt; A[i] &gt; A[i+1] &gt; ... &gt; A[A.length - 1]</code><br>Given an array that is definitely a mountain, return any <code>i</code> such that <code>A[0] &lt; A[1] &lt; ... A[i-1] &lt; A[i] &gt; A[i+1] &gt; ... &gt; A[A.length - 1]</code>.</p><p><strong>Example 1:</strong></p><ul><li>Input: [0,1,0]</li><li>Output: 1</li></ul><p><strong>Example 2:</strong></p><ul><li>Input: [0,2,1,0]</li><li>Output: 1</li></ul><p><strong>Note:</strong></p><ul><li>3 &lt;= A.length &lt;= 10000</li><li>0 &lt;= A[i] &lt;= 10^6</li><li>A is a mountain, as defined above.</li></ul></blockquote><h2 id="나의-풀이"><a href="#나의-풀이" class="headerlink" title="나의 풀이"></a>나의 풀이</h2><h3 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h3><p>배열에서 조건에 일치하는 첫번째 인덱스를 찾아주는 <code>findIndex()</code> 메소드를 사용했다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 56 ms</span></span><br><span class="line"><span class="keyword">var</span> peakIndexInMountainArray = <span class="function"><span class="keyword">function</span>(<span class="params">A</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> A.findIndex(<span class="function">(<span class="params">item, index, arr</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(index &lt; arr.length - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> item &gt; arr[index + <span class="number">1</span>];    </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>A 배열은 산이라고 했으니까 Math.max의 인덱스를 구하는 방법을 사용했다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 56ms</span></span><br><span class="line"><span class="keyword">var</span> peakIndexInMountainArray = <span class="function"><span class="keyword">function</span>(<span class="params">A</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> max = <span class="built_in">Math</span>.max(...A);</span><br><span class="line">    <span class="keyword">return</span> A.findIndex(<span class="function"><span class="params">item</span> =&gt;</span> item === max);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>근데 위의 방법은 indexOf로 더 짧게 풀 수 있다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 56ms</span></span><br><span class="line"><span class="keyword">var</span> peakIndexInMountainArray = <span class="function"><span class="keyword">function</span>(<span class="params">A</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> A.indexOf(<span class="built_in">Math</span>.max(...A))</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h2 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h2><p>문제가 크게 어렵지 않아서 파이썬으로도 풀어봤다.<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 40ms</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">peakIndexInMountainArray</span><span class="params">(self, A)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type A: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        number = <span class="number">0</span></span><br><span class="line">        before = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> A:</span><br><span class="line">            <span class="keyword">if</span> number &gt; <span class="number">1</span> <span class="keyword">and</span> i &lt; before:</span><br><span class="line">                <span class="keyword">return</span> number - <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                number = number + <span class="number">1</span></span><br><span class="line">                before = i</span><br></pre></td></tr></table></figure></p><h2 id="다른-사람-풀이"><a href="#다른-사람-풀이" class="headerlink" title="다른 사람 풀이"></a>다른 사람 풀이</h2><h3 id="Python-1"><a href="#Python-1" class="headerlink" title="Python"></a>Python</h3><p>파이썬의 for문은 자바스크립트의 for of처럼 i라는 변수에 리스트의 요소가 대입되니까 인덱스는 어떻게 구하지라고 생각했는데,<br>다음과 같이 <code>range</code>함수와 <code>len</code>함수를 이용하는 방법이 있었다.<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">peakIndexInMountainArray</span><span class="params">(self, A)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type A: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(A)<span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">if</span> A[i] &gt; A[i<span class="number">-1</span>] <span class="keyword">and</span> A[i]&gt; A[i+<span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">return</span> i</span><br></pre></td></tr></table></figure></p><ul><li>range(): 숫자 리스트를 자동으로 만들어 주는 함수</li><li>len(): 리스트 내 요소의 개수를 돌려주는 함수</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;Let’s call an array A a mountain if the following properties hold:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;A.length &amp;gt;= 3&lt;/code&gt;&lt;br&gt;There exists some
      
    
    </summary>
    
      <category term="Algorithm" scheme="http://chiabi.github.io/categories/Algorithm/"/>
    
    
      <category term="algorithm" scheme="http://chiabi.github.io/tags/algorithm/"/>
    
      <category term="leetcode" scheme="http://chiabi.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>7월 3주차 주간회고</title>
    <link href="http://chiabi.github.io/2018/07/22/retrospective/"/>
    <id>http://chiabi.github.io/2018/07/22/retrospective/</id>
    <published>2018-07-22T13:41:12.000Z</published>
    <updated>2018-07-22T17:38:57.041Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-퍼블리싱-외주와-커뮤니케이션"><a href="#1-퍼블리싱-외주와-커뮤니케이션" class="headerlink" title="1. 퍼블리싱 외주와 커뮤니케이션"></a>1. 퍼블리싱 외주와 커뮤니케이션</h2><p>지난주 학원에서 3일간 진행했던 해커톤에서의 만남을 계기로 한 사이트의 퍼블리싱을 맡게 되었다. 남은 공부와 구직(기업조사라든지, 포트폴리오 사이트라든지)에 전념해야 할 것 같아서 고민이 되었는데, 사이트 업종 자체가 내가 흥미를 느끼고 있던 분야의 것이고, 다른 사람의 디자인을 그대로 구현해보는 것은 오랜만이라 흥미가 생겨서 계약하게 되었다.<br>업체 대표님의 신뢰는 중개하는 분에 대한 신뢰인 것 같기도 하고 해커톤 산출물만으로 괜찮다고 생각했던 건지, 별다른 포트폴리오를 보여달라고 하지 않아서 조금 당황스러웠다. 그래도 상주해서 하는 작업이 아니라서 그런지 조금 우려는 하시는 것 같아서 작업 기간 동안 영업 종료시간(6시)에 작업 현황을 보내드리고 있다.  </p><p>웹에이전시에서 일할 당시에는 직접 클라이언트와 커뮤니케이션 할 일이 없었고, 직원끼리는(다른 팀이더라도) 조금 전문적인 용어를 써도 어느 정도 이해할 수 있는 범위여서 커뮤니케이션에 지장이 없었는데, 이번에 직접 업체 대표님과 대화를 해보니 나로서는 크게 어려운 말이 아니었다고 생각했어도 상대방에게는 어렵게 느껴진다는 걸 알았다. (조금이라도 웹 개발 쪽 언어라면 그게 ‘HTML, CSS’ 혹은 ‘퍼블리싱’이더라도 개발자가 아닌 이상은 듣는 입장에서 식은땀을 흘리게 되더라…)<br>첫 미팅은 월요일이었는데, 화요일에 학원에서 진행했던 특강에서 정원희 개발자님이 하신 말씀이 그다음 커뮤니케이션에 많은 도움이 되었다. 정원희 개발자님이 하신 말씀 중에 커뮤니케이션을 할 때 서버라는 용어조차 모르는 사람도 있으므로 전문적인 용어를 쓰지 않고 모두 쉬운 말로 풀어서 한다고 하셨다. 생각해보니 상대방이 어떤 사람이냐에 상관없이 전문적인 용어를 마구 써서 대화를 풀어나가려는 사람은 실질적으로 내재한 지식의 총량이 어느 정도이건 간에 커뮤니케이션 면에서는 이기적이고 무능한 사람인 것 같다. 그리고 사실 어려운 것을 쉽게 풀어 설명하는 게 더 어려운 일이다.<br>특강을 듣고나니 과연 나는 상대방을 배려한 대화를 했었는지 반성하게 되었다. </p><h2 id="2-정원희-개발자님-특강"><a href="#2-정원희-개발자님-특강" class="headerlink" title="2. 정원희 개발자님 특강"></a>2. 정원희 개발자님 특강</h2><p>화요일(7월 17일), 패스트캠퍼스에서 진행한 정원희 개발자님 특강을 들었다. (정원희 개발자님은 트레바리의 CTO이자 개발자로 일하고 계신다.)<br>‘왜 스타트업 개발자가 되었는 지’와 ‘스타트업에서 살아남는(사랑받는) 개발자가 되기 위해 무엇을 했는지’에 대해서 강의를 해주셨다.<br>중소기업이며, 설립한 지 10년도 넘은 웹에이전시에서만 일해봐서, 자사 서비스를 제공하는 스타트업을 도전하고 싶었는데, 내가 스타트업을 가려고 한다면 어떤 고민을 해야할 지 알 수 있는 강의였다.<br>정원희 개발자님이 욕심에 비해 의지가 약한 사람이기 때문에 강제로 개발하는 환경에 본인을 던지기 위해 최적인 곳으로 회사를 선택하셨다는데, 그 부분이 많이 공감이 되었고, 취업을 해야할지 부족한 나를 채우는 시간을 가져야할지 어느 것이 더 좋은 선택인지 고민하고 있는 내게 방향을 제시해주었다.<br>실패 후 다시 도전은 또 다른 가산점이라는 말씀도 많이 도움이 되었다. 구직을 하려다보면 자격요건에 요구되는 다양한 경험과 경력 사항들이 있다. 이것을 다 채우고 완벽한 지원자가 되려면 나에게 취업은 요원한 일이 될 것이다. 당장 모든 것이 완벽하지 않더라도 어느 정도 준비가 되어있다면 부딪치면서 채워나가야 될 것 같다. 그 부딪치는 과정에서도 나는 많은 것을 배울 수 있을 것이다.</p><h2 id="3-장고걸스-워크샵"><a href="#3-장고걸스-워크샵" class="headerlink" title="3. 장고걸스 워크샵"></a>3. 장고걸스 워크샵</h2><p>장고걸스 워크샵 후기는 나중에 또 시간을 들여 작성을 하려한다. 새로운 것을 배우는 것, 경험해보는 것은 즐거운 일이다. 굉장히 유익한 경험이 었고, 단순히 ‘장고라는 파이썬 기반 웹 프레임워크를 경험해 본다’ 이상의 경험이었다.<br>장고걸스 워크샵을 신청한 계기는 ‘잘 만들어진 튜토리얼을 제공한다해도 누구의 도움도 없이 생소한 언어와 생소한 기술을 사용해 보는 것은 굉장히 오랜 시간이 걸릴 수 있으니 워크샵을 통해 코치들의 도움을 받아 한 사이클을 빠르게 경험해보자’였다.<br>프론트엔드 개발 스쿨 전에 이 튜토리얼에 도전해보려 했는데, 마치 ‘이정도는 다 아시죠?’라는 느낌을 받았고, 모르는 것을 일일이 찾아보다보니 엄청난 시간이 소요되었다. 나는 어떠한 거대한 장벽을 바라보는 느낌이었다.<br>장고걸스 워크샵에서는 어떠한 바보같은 질문도 허용된다는 점이 가장 좋았다. 왜냐하면 초보 여성 개발자 혹은 개발에 입문하려는 여성들을 위한 모임이니까!<br>워크샵 동안 튜토리얼을 따라가는 데는 처음에 봤을때보다 큰 어려움이 없었다. 아마도 프론트엔드 개발 스쿨을 통해 개발에 대해 더 아는 것이 생겼기 때문이기도 할 거고, 가장 어려운 개발 환경 설정의 대부분이 이미 되어있었기 때문일 것이다.(git이라든지 에디터라든지) 블로그 만들기는 생각보다 수월하게 진행되었지만 가상환경이라거나, 파이썬 문법, 장고의 기능 같은 점을 코치님(이재열 개발자님)께 많이 질문했던 것 같다. 코치님도 어려운 부분을 쉽게 설명해주시려 고심해서 말을 골라가며 친절히 설명해주셨다.<br>밋업 같은 것은 아직 아는 사람이 없고, 개발 경험이 많지 않아서 과연 잘 어울릴 수 있을까 부담스러워서 도전하지 못하고 있는데, 그런면에서 장고걸스 워크샵은 입문자가 가장 접근하기 좋은 개발 커뮤니티인 것 같다.<br>프론트엔드 개발과 함께 파이썬, 장고도 꾸준히 공부해서 다음에는 코치로 참여하는 것을 목표로 해야겠다.</p><hr><p>이번주에 일일 회고를 제대로 하지 못했다. 지금 목표는 일일 회고 / 일일 알고리즘 문제 풀이 / 일일 커밋이다. 어려운 일이 아닌 것 같은데도 온전히 내가 만들어서 하는 일만 있는 게 아닌 경우는(외주를 맡거나 회사를 다니게 되면) 또 쉽지만은 않은 일이 되어버리는 것 같다.<br>제일 중요한 것은 결과가 나만의 책임이 아닌 일에 집중하는 것이지만, 그 사이에서도 시간 관리를 잘해서 내 개인적인 목표도 성취할 수 있도록 조율해야 겠다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-퍼블리싱-외주와-커뮤니케이션&quot;&gt;&lt;a href=&quot;#1-퍼블리싱-외주와-커뮤니케이션&quot; class=&quot;headerlink&quot; title=&quot;1. 퍼블리싱 외주와 커뮤니케이션&quot;&gt;&lt;/a&gt;1. 퍼블리싱 외주와 커뮤니케이션&lt;/h2&gt;&lt;p&gt;지난주 학원에서
      
    
    </summary>
    
      <category term="회고" scheme="http://chiabi.github.io/categories/%ED%9A%8C%EA%B3%A0/"/>
    
    
      <category term="회고" scheme="http://chiabi.github.io/tags/%ED%9A%8C%EA%B3%A0/"/>
    
  </entry>
  
  <entry>
    <title>UniqueMorseCodeWords</title>
    <link href="http://chiabi.github.io/2018/07/19/UniqueMorseCodeWords/"/>
    <id>http://chiabi.github.io/2018/07/19/UniqueMorseCodeWords/</id>
    <published>2018-07-19T02:16:33.000Z</published>
    <updated>2018-07-19T02:45:20.072Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>International Morse Code defines a standard encoding where each letter is mapped to a series of dots and dashes, as follows: “a” maps to “.-“, “b” maps to “-…”, “c” maps to “-.-.”, and so on.</p><p>For convenience, the full table for the 26 letters of the English alphabet is given below:</p><p><code>[&quot;.-&quot;,&quot;-...&quot;,&quot;-.-.&quot;,&quot;-..&quot;,&quot;.&quot;,&quot;..-.&quot;,&quot;--.&quot;,&quot;....&quot;,&quot;..&quot;,&quot;.---&quot;,&quot;-.-&quot;,&quot;.-..&quot;,&quot;--&quot;,&quot;-.&quot;,&quot;---&quot;,&quot;.--.&quot;,&quot;--.-&quot;,&quot;.-.&quot;,&quot;...&quot;,&quot;-&quot;,&quot;..-&quot;,&quot;...-&quot;,&quot;.--&quot;,&quot;-..-&quot;,&quot;-.--&quot;,&quot;--..&quot;]</code> </p><p>Now, given a list of words, each word can be written as a concatenation of the Morse code of each letter. For example, “cab” can be written as “-.-.-….-“, (which is the concatenation “-.-.” + “-…” + “.-“). We’ll call such a concatenation, the transformation of a word.</p><p>Return the number of different transformations among all words we have.</p><p><strong>Example:</strong></p><ul><li>Input: words = [“gin”, “zen”, “gig”, “msg”]</li><li>Output: 2</li><li>Explanation: </li><li>The transformation of each word is:<br>“gin” -&gt; “–…-.”<br>“zen” -&gt; “–…-.”<br>“gig” -&gt; “–…–.”<br>“msg” -&gt; “–…–.”</li></ul><p>There are 2 different transformations, “–…-.” and “–…–.”.</p><p><strong>Note:</strong></p><ul><li>The length of words will be at most 100.</li><li>Each words[i] will have length in range [1, 12].</li><li>words[i] will only consist of lowercase letters.</li></ul></blockquote><h2 id="나의-풀이"><a href="#나의-풀이" class="headerlink" title="나의 풀이"></a>나의 풀이</h2><p>유니크한 값을 찾으면 다른 수의 경우도 나올 것 같아서 Set을 이용해보았다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 64ms</span></span><br><span class="line"><span class="keyword">const</span> morse = [<span class="string">".-"</span>,<span class="string">"-..."</span>,<span class="string">"-.-."</span>,<span class="string">"-.."</span>,<span class="string">"."</span>,<span class="string">"..-."</span>,<span class="string">"--."</span>,<span class="string">"...."</span>,<span class="string">".."</span>,<span class="string">".---"</span>,<span class="string">"-.-"</span>,<span class="string">".-.."</span>,<span class="string">"--"</span>,<span class="string">"-."</span>,<span class="string">"---"</span>,<span class="string">".--."</span>,<span class="string">"--.-"</span>,<span class="string">".-."</span>,<span class="string">"..."</span>,<span class="string">"-"</span>,<span class="string">"..-"</span>,<span class="string">"...-"</span>,<span class="string">".--"</span>,<span class="string">"-..-"</span>,<span class="string">"-.--"</span>,<span class="string">"--.."</span>];  </span><br><span class="line"><span class="keyword">const</span> alphabet = <span class="string">'abcdefghijklmnopqrstuvwxyz'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> uniqueMorseRepresentations = <span class="function"><span class="keyword">function</span>(<span class="params">words</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> morseWords = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> word <span class="keyword">of</span> words) &#123;</span><br><span class="line">        <span class="keyword">let</span> newStr = <span class="string">''</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">const</span> i <span class="keyword">of</span> word) &#123;</span><br><span class="line">            newStr += morse[alphabet.indexOf(i)];</span><br><span class="line">        &#125;</span><br><span class="line">        morseWords.add(newStr)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> morseWords.size;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;International Morse Code defines a standard encoding where each letter is mapped to a series of dots and dashes, as follows:
      
    
    </summary>
    
      <category term="Algorithm" scheme="http://chiabi.github.io/categories/Algorithm/"/>
    
    
      <category term="algorithm" scheme="http://chiabi.github.io/tags/algorithm/"/>
    
      <category term="leetcode" scheme="http://chiabi.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>TIL</title>
    <link href="http://chiabi.github.io/2018/07/18/TIL/"/>
    <id>http://chiabi.github.io/2018/07/18/TIL/</id>
    <published>2018-07-18T02:14:25.000Z</published>
    <updated>2018-07-23T14:10:38.180Z</updated>
    
    <content type="html"><![CDATA[<h2 id="오늘-한-일"><a href="#오늘-한-일" class="headerlink" title="오늘 한 일"></a>오늘 한 일</h2><h3 id="Javascript30-14차"><a href="#Javascript30-14차" class="headerlink" title="Javascript30 14차"></a>Javascript30 14차</h3><ul><li>JavaScript References VS Copying</li></ul><p>원시 타입과 찹조타입의 복사에 관한 차이와 얕은복사, 깊은 복사에 대한 내용이었다.</p><p>다음은 배열을 복사하는 방법이다.(단, 얕은 복사)<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> cats = [<span class="string">'Syami'</span>, <span class="string">'Jojo'</span>, <span class="string">'Loki'</span>, <span class="string">'Kkonnim'</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> team1 = cats.slice();</span><br><span class="line"><span class="keyword">const</span> team2 = [].concat(cats);</span><br><span class="line"><span class="keyword">const</span> team3 = [...cats]</span><br><span class="line"><span class="keyword">const</span> team4 = <span class="built_in">Array</span>.from(cats)</span><br></pre></td></tr></table></figure></p><blockquote><p><a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/from" target="_blank" rel="noopener">Array.from()</a> 메서드는 배열의 형태를 갖거나 순회 가능한 객체로부터 얕게 복사한 Array 객체를 만듭니다.</p></blockquote><p>다음은 객체를 복사하는 방법이다.(단, 얕은 복사)<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> cat = &#123;</span><br><span class="line">  name: <span class="string">'Syami'</span>,</span><br><span class="line">  age: <span class="number">10</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> cat2 = <span class="built_in">Object</span>.assign(&#123;&#125;, cat, &#123; <span class="attr">kind</span>: <span class="string">'korean shot'</span>, <span class="attr">age</span>: <span class="number">11</span>&#125;)</span><br></pre></td></tr></table></figure></p><p>이러한 복사는 1 레벨의 깊이만 복사가 가능하다. 배열 안 배열 혹은 객체 안 배열 등등의 중첩되어 여러 레벨의 깊이가 생긴 객체(혹은 배열)을 복사하는 방법은 깊은 복사라고 하며 강의에서는 그 방법 중 하나를 소개해 줬는데 다음과 같다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> cat = &#123;</span><br><span class="line">  name: <span class="string">'Syami'</span>,</span><br><span class="line">  age: <span class="number">10</span>,</span><br><span class="line">  family: &#123;</span><br><span class="line">    brother: [<span class="string">'Jojo'</span>, <span class="string">'Loki'</span>],</span><br><span class="line">    sister: [<span class="string">'Kkonnim'</span>, <span class="string">'Samsun'</span>]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> cat2 = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(cat))</span><br></pre></td></tr></table></figure></p><p>그러나 이 방법은 성능상 매우 안 좋고, 직렬화 할 수 없는 속성들은(prototype이라든가) 날라가 버리기 때문에 좋은 방법은 아니라고 한다.</p><h3 id="파이널-프로젝트-2차-준비"><a href="#파이널-프로젝트-2차-준비" class="headerlink" title="파이널 프로젝트 2차 준비"></a>파이널 프로젝트 2차 준비</h3><p>서버를 GraphQL로 하자는 얘기가 나와서 다음의 영상들을 보게 되었는데, 많이 도움이 되었다.</p><ul><li><a href="https://www.youtube.com/watch?v=C57Pln3mNy0" target="_blank" rel="noopener">1강 GraphQL Server 만들기</a></li><li><a href="https://www.youtube.com/watch?v=1p-s99REAus" target="_blank" rel="noopener">Hello, GraphQL! Graph QL 도입으로 얻었던 효과 - 조민환</a></li></ul><p>그런데 프로젝트에 기획했지만 아직 구현되지 못한 부족한 부분이 많고, 처음부터 Apollo client를 쓰려니 잘 이해되지 않는 부분이 많아서 먼저 리덕스로 변경하는 것부터 처리하는 게 좋을 것 같아 리덕스를 먼저 해보기로 했다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;오늘-한-일&quot;&gt;&lt;a href=&quot;#오늘-한-일&quot; class=&quot;headerlink&quot; title=&quot;오늘 한 일&quot;&gt;&lt;/a&gt;오늘 한 일&lt;/h2&gt;&lt;h3 id=&quot;Javascript30-14차&quot;&gt;&lt;a href=&quot;#Javascript30-14차&quot; cla
      
    
    </summary>
    
      <category term="TIL" scheme="http://chiabi.github.io/categories/TIL/"/>
    
    
      <category term="TIL" scheme="http://chiabi.github.io/tags/TIL/"/>
    
  </entry>
  
  <entry>
    <title>Judge Route Circle</title>
    <link href="http://chiabi.github.io/2018/07/17/JudgeRouteCircle/"/>
    <id>http://chiabi.github.io/2018/07/17/JudgeRouteCircle/</id>
    <published>2018-07-17T14:40:55.000Z</published>
    <updated>2018-07-18T01:51:00.929Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Initially, there is a Robot at position (0, 0). Given a sequence of its moves, judge if this robot makes a circle, which means it moves back to the original place.</p><p>The move sequence is represented by a string. And each move is represent by a character. The valid robot moves are R (Right), L (Left), U (Up) and D (down). The output should be true or false representing whether the robot makes a circle.</p><p><strong>Example 1:</strong></p><ul><li>Input: “UD”</li><li>Output: true</li></ul><p><strong>Example 2:</strong></p><ul><li>Input: “LL”</li><li>Output: false</li></ul></blockquote><h2 id="나의-풀이"><a href="#나의-풀이" class="headerlink" title="나의 풀이"></a>나의 풀이</h2><p>문제 자체를 이해하기가 좀 어려웠다. 괜히 Circle이라 그래서 왜 원이 되지?라고 생각했는데, 그림을 그려보면 이해하기 쉬웠다. 예를들면 “RLUURDDLU”를 좌표 (0, 0)에서 시작한다고 생각해서 방향따라 그려보면 결국 다시 (0, 0)의 위치로 오게 된다. 이 경우 로봇이 원을 만든다고 가정하여 <code>true</code>를 반환하면 된다. 그래서 “LDRRLRUULR”의 경우 그려보면 (0, 0)의 위치로 돌아오지 않기 때문에 <code>false</code>를 반환하면 된다.  </p><p>정규식을 이용했다. R과 L의 수와 U와 D의 수가 같으면 원 위치로 되돌아갔다고 할 수 있으니까 다음과 같이 접근해서 풀어보았다.<br><code>|| []</code>이 부분은 마지막에 length로 구하고 싶은데 match 메소드가 정규식에 부합하는 문자열이 있으면 배열 형태로 반환하지만 없을 경우 <code>null</code>로 반환하기 때문에 정규식에 일치하는 문자가 없을 경우는 빈배열이 담기도록 하기 위해 추가했다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 68ms</span></span><br><span class="line"><span class="keyword">var</span> judgeCircle = <span class="function"><span class="keyword">function</span>(<span class="params">moves</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> R = moves.match(<span class="regexp">/R/g</span>) || [];</span><br><span class="line">  <span class="keyword">const</span> L = moves.match(<span class="regexp">/L/g</span>) || [];</span><br><span class="line">  <span class="keyword">const</span> U = moves.match(<span class="regexp">/U/g</span>) || [];</span><br><span class="line">  <span class="keyword">const</span> D = moves.match(<span class="regexp">/D/g</span>) || [];</span><br><span class="line">  <span class="keyword">return</span> R.length === L.length &amp;&amp; U.length === D.length</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>이번에는 for문을 통해 문자열을 하나씩 탐색해서 x와 y의 값에 변화를 주는 방법을 사용했다. 오른쪽으로 이동하면 x좌표가 1추가되고 왼쪽으로 이동하면 x좌표가 1 감소하는 것이라 모든 문자열을 탐색한 뒤에 x와 y의 좌표가 다시 0이 되었는지 확인한다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 72ms</span></span><br><span class="line"><span class="keyword">var</span> judgeCircle = <span class="function"><span class="keyword">function</span>(<span class="params">moves</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> y = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> i <span class="keyword">of</span> moves) &#123;</span><br><span class="line">        i === <span class="string">'R'</span> ? x++ : </span><br><span class="line">        i === <span class="string">'L'</span> ? x-- :</span><br><span class="line">        i === <span class="string">'U'</span> ? y-- :</span><br><span class="line">        i === <span class="string">'D'</span> &amp;&amp; y++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x === <span class="number">0</span> &amp;&amp; y === <span class="number">0</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>같은 접근법인데 reduce 메소드를 이용해 본 방법<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 72ms</span></span><br><span class="line"><span class="keyword">var</span> judgeCircle = <span class="function"><span class="keyword">function</span>(<span class="params">moves</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> arr = moves.split(<span class="string">''</span>);</span><br><span class="line">    <span class="keyword">const</span> hor = arr.reduce(<span class="function">(<span class="params">acc, item</span>) =&gt;</span> acc + (item === <span class="string">'R'</span> ? <span class="number">1</span> : item === <span class="string">'L'</span> ? <span class="number">-1</span> : <span class="number">0</span>), <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">const</span> ver = arr.reduce(<span class="function">(<span class="params">acc, item</span>) =&gt;</span> acc + (item === <span class="string">'U'</span> ? <span class="number">1</span> : item === <span class="string">'D'</span> ? <span class="number">-1</span> : <span class="number">0</span>), <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> !(hor + ver)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h2 id="다른-사람-풀이"><a href="#다른-사람-풀이" class="headerlink" title="다른 사람 풀이"></a>다른 사람 풀이</h2><p>같은 접근법인데 60ms이길래 환경이 달라서 그런 것 같아서 내가 다시 넣고 돌려보니 72ms가 걸렸다. 각 변수로 x, y를 넣는 대신 배열로 두고 switch 문을 사용한 방법이다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 72ms</span></span><br><span class="line"><span class="keyword">var</span> judgeCircle = <span class="function"><span class="keyword">function</span>(<span class="params">moves</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> origin = [<span class="number">0</span>,<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; moves.length; i++)&#123;</span><br><span class="line">        <span class="keyword">switch</span>(moves[i])&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'U'</span>:</span><br><span class="line">                origin[<span class="number">0</span>]++</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">case</span> <span class="string">'D'</span>:</span><br><span class="line">                origin[<span class="number">0</span>]--</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">case</span> <span class="string">'L'</span>:</span><br><span class="line">                origin[<span class="number">1</span>]--</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">case</span> <span class="string">'R'</span>:</span><br><span class="line">                origin[<span class="number">1</span>]++</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(origin[<span class="number">0</span>] == <span class="number">0</span> &amp;&amp; origin[<span class="number">1</span>] == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><hr><p>문제의 좋아요와 싫어요 수가 거의 비슷해서 왜 인가했는데, 문제 자체가 이해가 어려워서였던 것 같다. 괜히 원을 만든다는 가정이 문제를 이해하기 어렵게 했다. 근데 문제 자체를 이해하고 나니 풀이는 재미있었다.<br>특히 <code>match</code>메소드를 이용해서 <code>null</code>이 나오는데 배열의 <code>length</code> 프로퍼티로 비교하려고 하려면 어떻게 처리해야할까 고민했는데, <code>||</code> 논리 연산자를 이용해 match 메소드에서 <code>null</code>이 나오면 변수에 빈배열이 대입되도록 처리했다. 두번째 풀이의 삼항연산자에 쓴 것과 같이 <code>&amp;&amp;</code>와 <code>||</code>같은 논리 연산자의 특성을 활용해보니 코드가 굉장히 깔끔해보여서 기분이 좋았다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;Initially, there is a Robot at position (0, 0). Given a sequence of its moves, judge if this robot makes a circle, which mea
      
    
    </summary>
    
      <category term="Algorithm" scheme="http://chiabi.github.io/categories/Algorithm/"/>
    
    
      <category term="algorithm" scheme="http://chiabi.github.io/tags/algorithm/"/>
    
      <category term="leetcode" scheme="http://chiabi.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Hamming Distance</title>
    <link href="http://chiabi.github.io/2018/07/16/HammingDistance/"/>
    <id>http://chiabi.github.io/2018/07/16/HammingDistance/</id>
    <published>2018-07-16T02:07:15.000Z</published>
    <updated>2018-07-17T17:08:03.347Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/hamming-distance/description/" target="_blank" rel="noopener">leetcode 문제링크</a></p><blockquote><p><a href="https://en.wikipedia.org/wiki/Hamming_distance" target="_blank" rel="noopener">The Hamming distance</a> between two integers is the number of positions at which the corresponding bits are different.</p><p>Given two integers x and y, calculate the Hamming distance.</p><p><strong>Note:</strong></p><ul><li>0 ≤ x, y &lt; 231.</li></ul><p><strong>Example:</strong></p><ul><li>Input: x = 1, y = 4</li><li>Output: 2</li></ul><p><strong>Explanation:</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1   (0 0 0 1)</span><br><span class="line">4   (0 1 0 0)</span><br><span class="line">       ↑   ↑</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>The above arrows point to positions where the corresponding bits are different.</p></blockquote><h2 id="나의-풀이"><a href="#나의-풀이" class="headerlink" title="나의 풀이"></a>나의 풀이</h2><blockquote><p>※ <strong>해밍거리(Hamming Distance)</strong><br>블록 부호 이론에서, 해밍 거리(Hamming距離, 영어: Hamming distance)는 곱집합 위에 정의되는 거리 함수이다. 대략, 같은 길이의 두 문자열에서, 같은 위치에서 서로 다른 기호들이 몇 개인지를 센다.</p></blockquote><p>주어진 값들을 이진수 형태에서 비교해서 같은 위치에 다른 수가 몇개인지를 세면 되는 것 같다. 이진수로 바꾸는 방법은 toString 메소드를 사용했고, 수에 따라 같은 길이가 아닐 수 있으니 뒤의 수부터 비교해주기로 했다.<br>sort를 이용해 길이가 긴 수를 정해서 reduce를 통해 그 길이에 수가 둘 다 있으면 두 수(문자)를 비교해 다르면 누적에 1을 더하고 만약 위치에 수가 없으면 수가 있는 배열의 값이 ‘1’일 경우 더한다. </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 56 ms</span></span><br><span class="line"><span class="keyword">var</span> hammingDistance = <span class="function"><span class="keyword">function</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> arr = [x.toString(<span class="number">2</span>).split(<span class="string">''</span>).reverse(), y.toString(<span class="number">2</span>).split(<span class="string">''</span>).reverse()].sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> b.length - a.length);</span><br><span class="line">    <span class="keyword">return</span> arr[<span class="number">0</span>].reduce(<span class="function">(<span class="params">acc, item, index, array</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[<span class="number">1</span>][index] &amp;&amp; arr[<span class="number">1</span>][index] !== item) &#123;</span><br><span class="line">            <span class="keyword">return</span> acc + <span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!arr[<span class="number">1</span>][index] &amp;&amp; item === <span class="string">'1'</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> acc + <span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> acc</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="number">0</span>)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="다른-사람-풀이"><a href="#다른-사람-풀이" class="headerlink" title="다른 사람 풀이"></a>다른 사람 풀이</h2><p>이걸 한 줄로 푸네…</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 60ms</span></span><br><span class="line"><span class="keyword">var</span> hammingDistance = <span class="function"><span class="keyword">function</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (x ^ y).toString(<span class="number">2</span>).split(<span class="string">'0'</span>).join(<span class="string">''</span>).length;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="1-Bitwise-XOR"><a href="#1-Bitwise-XOR" class="headerlink" title="1. ^(Bitwise XOR)"></a>1. ^(Bitwise XOR)</h3><ul><li>MDN - <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Bitwise_Operators#Bitwise_XOR" target="_blank" rel="noopener">^(Bitwise XOR)</a></li><li>위키백과 - <a href="https://ko.wikipedia.org/wiki/%EB%B0%B0%ED%83%80%EC%A0%81_%EB%85%BC%EB%A6%AC%ED%95%A9" target="_blank" rel="noopener">배타적 논리합</a></li></ul><p>^부분이 이해가 안되었는데 XOR이라는 연산자로 다음의 표와 같이 a와 b가 다른 경우 1을 산출한다고 한다.  </p><table><thead><tr><th>a</th><th>b</th><th>a XOR b</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>0</td></tr><tr><td>0</td><td>1</td><td>1</td></tr><tr><td>1</td><td>0</td><td>1</td></tr><tr><td>1</td><td>1</td><td>0</td></tr></tbody></table><p>비트 연산자는 피연산자를 10진수나 16진수나 8진수와 같은 숫자가 아니라, 32비트(0과 1)의 집합으로 표현한다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.    9 (base 10) = 00000000000000000000000000001001 (base 2)</span><br><span class="line">    14 (base 10) = 00000000000000000000000000001110 (base 2)</span><br><span class="line">                   --------------------------------</span><br><span class="line">14 ^ 9 (base 10) = 00000000000000000000000000000111 (base 2) = 7 (base 10)</span><br></pre></td></tr></table></figure><p>그렇다면 위의 풀이에서 x, y 간의 배타적 논리합을 구해서 그 수의 이진수 표현(문자열) 중 문자 ‘0’을 제거하면(split(‘0’)) ‘1’만 남게 되는 데 이 1은 x, y가 같은 위치에 다른 문자였음을 의미하니까 그 길이를 구하면 원하는 결과를 얻을 수 있다.  </p><hr><p>다만, 왜 이 풀이가 내 풀이보다 느린 지 아직 잘 모르겠다. 처음에는 32비트 집합간의 비교라서 그런건가 했는데 비트가 더…느릴 수…있나? 왠지 환경에 따라 다를 것 같은 미미한 차이라…</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/hamming-distance/description/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;leetcode 문제링크&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;
      
    
    </summary>
    
      <category term="Algorithm" scheme="http://chiabi.github.io/categories/Algorithm/"/>
    
    
      <category term="algorithm" scheme="http://chiabi.github.io/tags/algorithm/"/>
    
      <category term="leetcode" scheme="http://chiabi.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>flip And Invert Image</title>
    <link href="http://chiabi.github.io/2018/07/15/flipAndInvertImage/"/>
    <id>http://chiabi.github.io/2018/07/15/flipAndInvertImage/</id>
    <published>2018-07-15T13:42:39.000Z</published>
    <updated>2018-07-17T15:54:44.580Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/flipping-an-image/description/" target="_blank" rel="noopener">leetcode 문제링크</a></p><blockquote><p>Given a binary matrix A, we want to flip the image horizontally, then invert it, and return the resulting image.</p><p>To flip an image horizontally means that each row of the image is reversed.  For example, flipping [1, 1, 0] horizontally results in [0, 1, 1].</p><p>To invert an image means that each 0 is replaced by 1, and each 1 is replaced by 0. For example, inverting [0, 1, 1] results in [1, 0, 0].</p><p><strong>Example 1:</strong>  </p><ul><li>Input: [[1,1,0],[1,0,1],[0,0,0]]</li><li>Output: [[1,0,0],[0,1,0],[1,1,1]]</li><li>Explanation: First reverse each row: [[0,1,1],[1,0,1],[0,0,0]].</li><li>Then, invert the image: [[1,0,0],[0,1,0],[1,1,1]]</li></ul><p><strong>Example 2:</strong>  </p><ul><li>Input: [[1,1,0,0],[1,0,0,1],[0,1,1,1],[1,0,1,0]]</li><li>Output: [[1,1,0,0],[0,1,1,0],[0,0,0,1],[1,0,1,0]]</li><li>Explanation: First reverse each row: [[0,0,1,1],[1,0,0,1],[1,1,1,0],[0,1,0,1]].</li><li>Then invert the image: [[1,1,0,0],[0,1,1,0],[0,0,0,1],[1,0,1,0]]</li></ul><p><strong>Notes:</strong>  </p><ul><li>1 &lt;= A.length = A[0].length &lt;= 20</li><li>0 &lt;= A[i][j] &lt;= 1</li></ul></blockquote><h2 id="나의-풀이"><a href="#나의-풀이" class="headerlink" title="나의 풀이"></a>나의 풀이</h2><p>문제를 요약하면 0과 1로만 이루어진 2차원 배열을 수평으로 한번 뒤집고, 0은 1로 1은 0으로 치환되면 된다.<br>이미지 파일을 뒤집는 방법이 이런식으로 이루어지나 보다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 72 ms</span></span><br><span class="line"><span class="keyword">var</span> flipAndInvertImage = <span class="function"><span class="keyword">function</span>(<span class="params">A</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> arr = A;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = arr.length, n = arr[<span class="number">0</span>].length; i &lt; l; i++) &#123;</span><br><span class="line">        arr[i].reverse();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            arr[i][j] = arr[i][j] === <span class="number">1</span> ? <span class="number">0</span> : <span class="number">1</span>; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>2차원 배열이니 for문을 2번 썼다.<br>for문을 두번 쓰는 다음과 같은 경우에는 적절한 것 같은데, reverse가 원본 배열을 바꾸는 메소드이고 <code>arr[i][j]</code>에 값을 대입하는 부분 역시 원본 배열에 변화를 주기 때문에 만약에 원본 배열에 영향을 주고 싶지 않다면 깊은복사를 할 수 있도록 고려해야 될 것 같다.</p><p>그렇다면 다음과 같은 방법을 사용하면 인자로 넘겨지는 원본 배열에 변형 없이 새로운 배열을 얻을 수 있다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 68 ms</span></span><br><span class="line"><span class="keyword">var</span> flipAndInvertImage = <span class="function"><span class="keyword">function</span>(<span class="params">A</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> newArr = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = A.length, n = A[<span class="number">0</span>].length; i &lt; l; i++) &#123;</span><br><span class="line">        <span class="keyword">const</span> newRow = A[i].concat().reverse();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            newRow[j] = newRow[j] === <span class="number">1</span> ? <span class="number">0</span> : <span class="number">1</span>; </span><br><span class="line">        &#125;</span><br><span class="line">        newArr.push(newRow);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newArr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>또 다른 방법으로 <code>for of</code> 문을 쓰면서 <code>map</code> 메소드를 사용하는 방법을 써봤다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 64 ms</span></span><br><span class="line"><span class="keyword">var</span> flipAndInvertImage = <span class="function"><span class="keyword">function</span>(<span class="params">A</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> newArr = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> i <span class="keyword">of</span> A) &#123;</span><br><span class="line">        <span class="keyword">const</span> newRow = i.concat().reverse().map(<span class="function"><span class="params">item</span> =&gt;</span> item === <span class="number">1</span> ? <span class="number">0</span> : <span class="number">1</span>)</span><br><span class="line">        newArr.push(newRow);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newArr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="다른-사람-풀이"><a href="#다른-사람-풀이" class="headerlink" title="다른 사람 풀이"></a>다른 사람 풀이</h2><p>map을 두번 써서 풀었다. 그런데 이 풀이도 만약에 원본 배열을 바꾸고 싶지 않다면 reverse() 메소드 이전에 복사하는 부분이 없기 때문에 변형이 생긴다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> flipAndInvertImage = <span class="function"><span class="keyword">function</span>(<span class="params">A</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> A.map(<span class="function"><span class="params">row</span> =&gt;</span> row.reverse().map(<span class="function"><span class="params">num</span> =&gt;</span> num ? <span class="number">0</span> : <span class="number">1</span>))</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/flipping-an-image/description/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;leetcode 문제링크&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;

      
    
    </summary>
    
      <category term="Algorithm" scheme="http://chiabi.github.io/categories/Algorithm/"/>
    
    
      <category term="algorithm" scheme="http://chiabi.github.io/tags/algorithm/"/>
    
      <category term="leetcode" scheme="http://chiabi.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Jewels and Stones</title>
    <link href="http://chiabi.github.io/2018/07/09/Stones/"/>
    <id>http://chiabi.github.io/2018/07/09/Stones/</id>
    <published>2018-07-09T14:19:43.000Z</published>
    <updated>2018-07-09T15:21:35.591Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/jewels-and-stones/description/" target="_blank" rel="noopener">leetcode 문제링크</a></p><blockquote><p>You’re given strings <code>J</code> representing the types of stones that are jewels, and <code>S</code> representing the stones you have.  Each character in <code>S</code> is a type of stone you have.  You want to know how many of the stones you have are also jewels.</p><p>The letters in J are guaranteed distinct, and all characters in <code>J</code> and <code>S</code> are letters. Letters are case sensitive, so “a” is considered a different type of stone from “A”.</p><p><strong>Example 1:</strong></p><ul><li>Input: J = “aA”, S = “aAAbbbb”</li><li>Output: 3</li></ul><p><strong>Example 2:</strong></p><ul><li>Input: J = “z”, S = “ZZ”</li><li>Output: 0</li></ul><p><strong>Note:</strong><br><code>S</code> and <code>J</code> will consist of letters and have length at most 50.<br>The characters in <code>J</code> are distinct.</p></blockquote><h2 id="나의-풀이"><a href="#나의-풀이" class="headerlink" title="나의 풀이"></a>나의 풀이</h2><p>오랜만에 풀려니 머리가 잘 굴러가지 않는데 그럴땐 일단 가장 단순 무식한 방법으로 (Brute force 식으로) 풀어버리는 게 가장 좋은 것 같다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 60ms</span></span><br><span class="line"><span class="keyword">var</span> numJewelsInStones = <span class="function"><span class="keyword">function</span>(<span class="params">J, S</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">const</span> jArr = J.split(<span class="string">''</span>);</span><br><span class="line">    <span class="keyword">const</span> sArr = S.split(<span class="string">''</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = jArr.length; i &lt; l; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>, m = sArr.length; j &lt; m; j++) &#123;</span><br><span class="line">            sArr[j] === jArr[i] &amp;&amp; num++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>아니 근데 반복문 2번은 돌려야 풀 수 있는 문제네;;<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 64ms</span></span><br><span class="line"><span class="keyword">var</span> numJewelsInStones = <span class="function"><span class="keyword">function</span>(<span class="params">J, S</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> i <span class="keyword">of</span> J) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> j <span class="keyword">of</span> S) &#123;</span><br><span class="line">            j === i &amp;&amp; num++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h2 id="다른-사람-풀이"><a href="#다른-사람-풀이" class="headerlink" title="다른 사람 풀이"></a>다른 사람 풀이</h2><p>reduce 메서드를 이용한 방법<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 52ms</span></span><br><span class="line"><span class="keyword">var</span> numJewelsInStones = <span class="function"><span class="keyword">function</span>(<span class="params">J, S</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> jewels = J.split(<span class="string">''</span>);</span><br><span class="line">  <span class="keyword">return</span> S.split(<span class="string">''</span>).reduce(<span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(jewels.includes(b)) &#123;</span><br><span class="line">      a += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">  &#125;, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/jewels-and-stones/description/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;leetcode 문제링크&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;

      
    
    </summary>
    
      <category term="Algorithm" scheme="http://chiabi.github.io/categories/Algorithm/"/>
    
    
      <category term="algorithm" scheme="http://chiabi.github.io/tags/algorithm/"/>
    
      <category term="leetcode" scheme="http://chiabi.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>TIL 20180624</title>
    <link href="http://chiabi.github.io/2018/06/24/TIL/"/>
    <id>http://chiabi.github.io/2018/06/24/TIL/</id>
    <published>2018-06-24T11:24:53.000Z</published>
    <updated>2018-06-24T13:41:27.780Z</updated>
    
    <content type="html"><![CDATA[<h2 id="오늘-한-일"><a href="#오늘-한-일" class="headerlink" title="오늘 한 일"></a>오늘 한 일</h2><h3 id="파이널-프로젝트"><a href="#파이널-프로젝트" class="headerlink" title="파이널 프로젝트"></a>파이널 프로젝트</h3><ul><li>팀 명: geek-ryan</li><li>프로젝트 명: <a href="https://github.com/geek-ryan/seemva" target="_blank" rel="noopener">seemva</a></li></ul><h4 id="Ant-Design-테스트"><a href="#Ant-Design-테스트" class="headerlink" title="Ant Design 테스트"></a><a href="https://ant.design/docs/react/getting-started" target="_blank" rel="noopener">Ant Design</a> 테스트</h4><p>리액트 컴포넌트로 제공하거나 form 같은 경우 verify 해주는 부분의 가이드를 제공해준다. 나중에 만들어 볼지도 모를 calendar컴포넌트도 제공하고, airbnb의 datapicker를 사용하려고 했었는데, 이 역시 컴포넌트로 제공하고 있다. timeline 컴포넌트는 프로젝트에서 쓰려고 하는 것과 맞지 않아서 아쉽지만…<br>각자 테스트 해본 뒤 방향을 결정하기로 했는데, 논의 끝에 우선 이 디자인 컴포넌트를 이용해 보기로 했다.</p><h4 id="와이어프레임"><a href="#와이어프레임" class="headerlink" title="와이어프레임"></a>와이어프레임</h4><p>각자 벤치마킹을 해보고 와이어프레임을 그려보기로 했다. 논의는 트렐로를 통해 이루어졌다. 벤치마킹한 사이트의 이미지나 링크를 트렐로를 통해 공유하고, 팀원이 손그림으로 와이어프레임을 그린 것을 트렐로에 올린 것을 <a href="https://ovenapp.io/" target="_blank" rel="noopener">카카오 oven</a>을 통해 정리했다.<br>로그인, 회원가입, 보드 화면까지만 만들었는데, 한꺼번에 하기보다는 먼저 컴포넌트별, 페이지별로 개발을 들어가면서 수정하고 추가하는 식으로 진행하는 것이 좋을 것 같다.</p><ul><li>로그인, 회원가입: chiabi</li><li>보드화면, 보드의 사이드바: akiraei</li></ul><h4 id="네이밍-컨벤션"><a href="#네이밍-컨벤션" class="headerlink" title="네이밍 컨벤션"></a>네이밍 컨벤션</h4><blockquote><p><strong>예. Login form</strong></p><p>directory : filename</p><ul><li>components: UserFormButtonPC.js</li><li>containers:UserFormButtonCC.js</li><li>contexts: UserFormCTX.js</li><li>pages: LoginPage.js</li><li>hocs: withAuth.js</li><li>serverAPI.js</li></ul><p>※ components 파일에서 PC 작성시 반드시 storybook 파일 남길 것<br>UserFormButtonPC.stories.js</p><p>※ 되도록 축약 표현이 아닌 풀 네임으로 만들것 (Btn(x), Button(o))</p></blockquote><h4 id="앞으로-사용-예정인-라이브러리"><a href="#앞으로-사용-예정인-라이브러리" class="headerlink" title="앞으로 사용 예정인 라이브러리"></a>앞으로 사용 예정인 라이브러리</h4><ul><li>드래그앤 드롭 - <a href="https://github.com/react-dnd/react-dnd" target="_blank" rel="noopener">react-dnd</a></li><li>타임라인 - <a href="https://www.npmjs.com/package/react-calendar-timeline" target="_blank" rel="noopener">react-calendar-timeline</a></li></ul><p>프로필 부분은 고민이다. 사진을 올릴 수 있어야하는데, 이미지 서버를 따로 두는 방법을 고민 중이다. 이부분을 내가 테스트해보기로 해서 로그인과 회원가입 부분을 맡기로 했다.  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;오늘-한-일&quot;&gt;&lt;a href=&quot;#오늘-한-일&quot; class=&quot;headerlink&quot; title=&quot;오늘 한 일&quot;&gt;&lt;/a&gt;오늘 한 일&lt;/h2&gt;&lt;h3 id=&quot;파이널-프로젝트&quot;&gt;&lt;a href=&quot;#파이널-프로젝트&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
      <category term="TIL" scheme="http://chiabi.github.io/categories/TIL/"/>
    
    
      <category term="TIL" scheme="http://chiabi.github.io/tags/TIL/"/>
    
  </entry>
  
  <entry>
    <title>TIL 20180622</title>
    <link href="http://chiabi.github.io/2018/06/23/TIL/"/>
    <id>http://chiabi.github.io/2018/06/23/TIL/</id>
    <published>2018-06-22T15:12:20.000Z</published>
    <updated>2018-07-17T17:09:59.754Z</updated>
    
    <content type="html"><![CDATA[<h2 id="오늘-한-일"><a href="#오늘-한-일" class="headerlink" title="오늘 한 일"></a>오늘 한 일</h2><h3 id="1-프론트엔드-개발-스쿨"><a href="#1-프론트엔드-개발-스쿨" class="headerlink" title="1. 프론트엔드 개발 스쿨"></a>1. 프론트엔드 개발 스쿨</h3><p>강사님이 게시판 게시글 CRUD와 댓글은 보여주는 것 까지만 구현하신 코드를 보면서 설명해주셨다.<br>코드를 보니 또 내가 생각한 것과는 context 설계가 달랐다. 나는 post 폼은 PostListContext.js(componentDidMount 훅에 서버로 포스트 리스트에 대해서 GET 요청을 보내는 부분이 있는)에 서버에 POST하는 메소드를 추가해서 post 폼 컨테이너로 내려보내고, 나중에 post 폼 수정 페이지에서는 PostContext.js(componentDidMount 훅에 서버로 특정 포스트에 대해서 GET 요청을 보내는 부분이 있는)에 PATCH 요청을 보내는 메소드를 추가해서 내려보내는 식으로 해서 context를 같이 사용하려고 했는데, 강사님은 폼 추가/삭제에 대한 context를 따로 만들어서 id가 있을 경우에 따라 조건문을 통해 componentDidMount 훅에서 특정 포스트에 대한 GET 요청을 보내는 식으로 구현하셨다.<br>그리고 내가 간과하고 있던 것이 나는 게시글 추가 시에 게시판 목록으로 Redirect를 걸었는데 생각해보니 사용자의 관점에서는 게시글 목록이 아니라 생성된 게시글의 보기 페이지로 Redirect를 걸어주는 게 맞는 것 같다.</p><p>그리고 페이지는 함수형 컴포넌트로 만들었는데, 그러면서 화살표 함수로 만들면서 익명함수로 만든게 개발자 도구에서는 Unknown으로 보인다는 것도 알게 되었다. 그리고 Router부분을 나는 이슈 페이지에서 찾은 코드를 추가했는데, storybook-react-router라는 라이브러리가 있어서 그걸 쓰면 더 간략한 코드로 내가 처리한 부분을 대체할 수 있었다.</p><p>나는 Components 디렉터리의 PC 컴포넌트에서 username이나 password 상태를 관리하고 Context의 메소드를 내려받아서 핸들링해줬는데, 강사님은 Container에서 처리해주셨다. 이부분은 따로 여쭤봤는데, 물론 PC에서 관리해도 그것은 어떻게 설계하느냐(말하자면 관리 정책 측면이라)에 따른 거라 문제 될 것은 없지만, 로그인의 경우 사용자 입력을 받아 서버에 요청을 보내고 성공했는지에 따라 success 상태를 토글해서 Redirect를 걸어준다면 그 부분은 외부와 연동되는 부분이 들어가게 되니까 CC에서 처리하는 게 좋을 거라고 생각했다고 하셨다.</p><h3 id="2-파이널-프로젝트-회의"><a href="#2-파이널-프로젝트-회의" class="headerlink" title="2. 파이널 프로젝트 회의"></a>2. 파이널 프로젝트 회의</h3><p>파이널 프로젝트로 쇼핑몰을 할 지 기존에 템플릿으로 만들어봤던 프로젝트 관리 서비스를 만들지 고민했다. 팀원이랑 의논 끝에 기존에 만들어본 프로젝트 관리 서비스를 하는 대신에 규모를 더 키워보기로 했다. 이전에는 사용자의 프로젝트 todo 리스트에 가까웠다면 이번에는 아예 팀 별로 프로젝트를 생성해서 관리할 수 있는 트렐로, asana 같은 서비스를 만들어보기로 했다.(물론 그들이 제공하는 모든 기능을 구현할 수는 없겠지만) 그리고 라이브러리를 이용해 타임라인과 캘린더 보기까기 구현해보기로 계획했다.<br>오늘 강사님이 알려주신 eslint와 prettier 설정으로 코딩 스타일은 얼추 맞출 수 있게 되었고, 구체적으로 설계하는 부분은 같이 맞춰나가기로 했다. 기능단위로 PC를 먼저 구현한 뒤에 일단 Context를 만들어 상태를 관리하고 Context에서 보관할 필요가 없는 상태라면 CC에서 처리해주기로 했다.  </p><p>오늘은 일단 프로젝트를 어느정도 규모로 할 지와 나중에 수정할지라고 일단 컴포넌트 작성 순서와 상태 관리를 어디에서 할 건지 먼저 정하고, 내일은 일단 어느정도 와이어프레임을 위해 각자 벤치마킹을 해보고 일요일까지 와이어프레임을 만든 뒤 기능 별 분담을 하기로 했다.</p><p>2주내에 다 할 수 있을까 조금 걱정이 되긴 하는데, 만드는 것은 재미있을 것 같다. 목표한대로 1주 정도는 전체적으로 만들고 남은 기간에는 스타일링과 코드 개선을 할 수 있으면 좋겠다. </p><h2 id="내일-할-일"><a href="#내일-할-일" class="headerlink" title="내일 할 일"></a>내일 할 일</h2><ul><li>파이널 프로젝트 와이어프레임을 위한 벤치마킹</li><li>강사님 게시판 코드 읽어보고 연습하기</li><li>Ant Design 써보기</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;오늘-한-일&quot;&gt;&lt;a href=&quot;#오늘-한-일&quot; class=&quot;headerlink&quot; title=&quot;오늘 한 일&quot;&gt;&lt;/a&gt;오늘 한 일&lt;/h2&gt;&lt;h3 id=&quot;1-프론트엔드-개발-스쿨&quot;&gt;&lt;a href=&quot;#1-프론트엔드-개발-스쿨&quot; class=&quot;he
      
    
    </summary>
    
      <category term="TIL" scheme="http://chiabi.github.io/categories/TIL/"/>
    
    
      <category term="TIL" scheme="http://chiabi.github.io/tags/TIL/"/>
    
  </entry>
  
  <entry>
    <title>TIL 2018021</title>
    <link href="http://chiabi.github.io/2018/06/21/TIL/"/>
    <id>http://chiabi.github.io/2018/06/21/TIL/</id>
    <published>2018-06-21T14:24:55.000Z</published>
    <updated>2018-06-22T15:17:37.746Z</updated>
    
    <content type="html"><![CDATA[<h2 id="오늘-한-일"><a href="#오늘-한-일" class="headerlink" title="오늘 한 일"></a>오늘 한 일</h2><h3 id="1-리액트로-게시판-만들기"><a href="#1-리액트로-게시판-만들기" class="headerlink" title="1. 리액트로 게시판 만들기"></a>1. 리액트로 게시판 만들기</h3><p>다 완성하고 싶었는데, 오류도 잡고 어떻게 만들어야할까 고민하다보니 댓글까지는 넣지 못했다.<br>원래는 PostList와 Post Context로 분리하지 않고 Post Context 하나로 모든 상태를 같이 관리하려고 했는데, 강사님이 보여주신 코드를 보니 list와 view에서 쓸 수 있는 Context를 따로 나누셨다. 왜 그렇게 하셨을까 생각을 해보니 나는 어차피 post를 모두 불러오니까 그걸로 filter메소드 등을 써서 특정 id의 post를 찾으면 되지 않을까라고 생각했는데(뷰페이지는 그렇게 만들기까지 했었다.), 새 글 작성은 몰라도 글을 수정하는 페이지를 어떻게 처리할 건가 생각해보니 componetDidMount시에 보내는 요청이 다르기 때문에 따로 context를 분리하는 게 더 나을것 같아서 수정했다.<br>router 사용시 ‘/post’(리스트) ‘/post/write’(새 글 작성), ‘/post/1’(뷰페이지) 이렇게 주소가 표시되도록 하려고 했는데, write 페이지가 렌더링 되지 않았다. 이유는 ‘/post/write역시 ‘/post/:postId’ Route에 걸리기 때문이었다. ‘/post/write’ Route에 exact를 추가하고 위로 올리니 해결되었다.<br>그 다음 문제는 write페이지에서<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET https://&#123;server&#125;/posts/write?_expand=user 404 ()</span><br></pre></td></tr></table></figure></p><p>이런식으로 404에러를 던지고 있는데, 왜 저런식으로 요청을 보내나했더니 처음에는 <code>&lt;Route&gt;</code>를 <code>&lt;Switch&gt;</code>로 둘러줬다가 exact를 쓰니까 제거해도 되지 않을까 했는데, 그렇게 되면 write일때도 걸리고 post의 params로도 걸려서 뷰페이지도 렌더링 되고 있었다. 다시 <code>&lt;Switch&gt;</code>로 둘러줘서 하나의 Route만 걸리도록 했더니 해결되었다.<br>스토리북에서 테스트하는 컴포넌트에 react router의 컴포넌트 사용으로 오류가 자꾸 발생되었는데, 이부분은 찾아보니 스토리북 깃헙에 이슈로 올라와 있었다. <a href="https://github.com/storybooks/storybook/issues/769" target="_blank" rel="noopener">addDecorator를 이용한 해결방법도 찾을 수 있었다.</a></p><h2 id="내일-할-일"><a href="#내일-할-일" class="headerlink" title="내일 할 일"></a>내일 할 일</h2><ul><li>파이널 프로젝트 기획하기</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;오늘-한-일&quot;&gt;&lt;a href=&quot;#오늘-한-일&quot; class=&quot;headerlink&quot; title=&quot;오늘 한 일&quot;&gt;&lt;/a&gt;오늘 한 일&lt;/h2&gt;&lt;h3 id=&quot;1-리액트로-게시판-만들기&quot;&gt;&lt;a href=&quot;#1-리액트로-게시판-만들기&quot; class=&quot;
      
    
    </summary>
    
      <category term="TIL" scheme="http://chiabi.github.io/categories/TIL/"/>
    
    
      <category term="TIL" scheme="http://chiabi.github.io/tags/TIL/"/>
    
  </entry>
  
  <entry>
    <title>TIL 20180620</title>
    <link href="http://chiabi.github.io/2018/06/20/TIL-1/"/>
    <id>http://chiabi.github.io/2018/06/20/TIL-1/</id>
    <published>2018-06-20T13:23:10.000Z</published>
    <updated>2018-06-21T14:44:45.963Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-프론트엔드-스쿨과정-리액트"><a href="#1-프론트엔드-스쿨과정-리액트" class="headerlink" title="1. 프론트엔드 스쿨과정 - 리액트"></a>1. 프론트엔드 스쿨과정 - 리액트</h3><ul><li>HOC로 인증 관련 문제 해결하기</li><li>defaultProps</li><li>Sass 사용하기</li><li>classnames</li><li>규모있는 프로젝트의 개발 순서는 어떻게 가져가야 할까?</li></ul><p>Sass 사용은 visual studio code에서 바로 컴파일 해주는 익스텐션을 사용하도록 알려주셨는데, 시간이 나면 webpack을 이용하는 방법을 알아봐야겠다.</p><h3 id="2-리액트로-게시판-만들기"><a href="#2-리액트로-게시판-만들기" class="headerlink" title="2. 리액트로 게시판 만들기"></a>2. 리액트로 게시판 만들기</h3><p>기본적인 로그인 구현까지했다. 스토리북을 이용해서 Presentational 컴포넌트를 먼저 확인하면서 만들고 있다. 만들다가 기억이 잘 안나는 부분은 다시 todo 실습으로 돌아가서 참고하고 있는데, rgb 챌린지처럼 먼저 단순하게 만들고 더 다듬어야 될 것 같다. 아직 어느 코드가 중복되는 로직일지 파악할 수 없어서 오늘 배운 HOC은 적용해보지 못했는데, 다듬다보면 어느때 써야할 지 감이 잡힐 것 같다. 이번 과제로 게시판을 한번 만들어보면 마지막 과제를 할 때 많은 도움이 될 것 같다.</p><h2 id="내일-할-일"><a href="#내일-할-일" class="headerlink" title="내일 할 일"></a>내일 할 일</h2><ul><li>리액트로 게시판 만들기 과제 완료하기<ul><li>로그인<ul><li>데이터설계(json server)</li><li>presentational: 로그인 화면</li><li>Provider: 상태관리</li><li>Container 컴포넌트 (PC와 Provider를 이어줄)</li></ul></li><li>글 목록</li><li>글 작성</li><li>댓글 목록</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-프론트엔드-스쿨과정-리액트&quot;&gt;&lt;a href=&quot;#1-프론트엔드-스쿨과정-리액트&quot; class=&quot;headerlink&quot; title=&quot;1. 프론트엔드 스쿨과정 - 리액트&quot;&gt;&lt;/a&gt;1. 프론트엔드 스쿨과정 - 리액트&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;HO
      
    
    </summary>
    
      <category term="TIL" scheme="http://chiabi.github.io/categories/TIL/"/>
    
    
      <category term="TIL" scheme="http://chiabi.github.io/tags/TIL/"/>
    
  </entry>
  
  <entry>
    <title>TIL 20180619</title>
    <link href="http://chiabi.github.io/2018/06/20/TIL/"/>
    <id>http://chiabi.github.io/2018/06/20/TIL/</id>
    <published>2018-06-19T16:26:50.000Z</published>
    <updated>2018-06-21T14:29:49.036Z</updated>
    
    <content type="html"><![CDATA[<h2 id="오늘-한-일"><a href="#오늘-한-일" class="headerlink" title="오늘 한 일"></a>오늘 한 일</h2><h3 id="1-프론트엔드-스쿨과정-리액트"><a href="#1-프론트엔드-스쿨과정-리액트" class="headerlink" title="1. 프론트엔드 스쿨과정 - 리액트"></a>1. 프론트엔드 스쿨과정 - 리액트</h3><ul><li>Provider의 적절한 위치는?</li><li>마운트되었을 때 부작용을 일으키는 컴포넌트 (OnMount 컴포넌트)</li><li>브라우저의 중요한 UI - 주소표시줄, hash, 새로고침, 뒤로가기, 앞으로가기</li><li>HTML5 history API &amp; hashchange</li><li>react-router 소개 및 실습</li></ul><p>‘만약 단순한 모달 정도가 아니라 페이지가 이동되는 것 같이 느껴지도록 만들려면 리액트로 어떻게 해야하지?’ 라는 고민이 해결되었다. 리액트 라우터를 통해 굉장히 쉽게 구현할 수 있었다. 강사님께서 리액트 라우터에 대해 설명하기 전에 마운트되었을 때 부작용을 일으키는 컴포넌트나 history객체, pushState 같은 바탕이 되는 개념을 먼저 설명해주셔서 덕분에 크게 어렵게 느껴지지 않았다.<br>리액트 라우터를 배우고 나니 파이널 프로젝트에서는 쇼핑몰을 도전해보고 싶어졌다.</p><h3 id="2-rgb-챌린지-게임-수정"><a href="#2-rgb-챌린지-게임-수정" class="headerlink" title="2. rgb 챌린지 게임 수정"></a>2. rgb 챌린지 게임 수정</h3><p>강사님이 코드 리뷰를 해주신 것을 토대로 다시 수정했다. 컬러 코드, 스테이지, 점수 등이 서로 결합되어 있기 때문에 GameContext라는 하나의 컴포넌트에서 모든 상태를 관리하는 방법으로 해볼 것을 조언해주셔서 ColorContext와 ResultContext, ScoreContext로 나눴던 것을 GameContext로 합쳤다. 그리고 GameConsumer를 사용하게 되는 부분은 Container 컴포넌트로 따로 만들었다.<br>컴포넌트가 너무 많은것이 아닌가 걱정이었는데, context 컴포넌트를 줄였음에도 Presentaional 컴포넌트와 Container 컴포넌트로 분리해보려고 했더니 컴포넌트가 많아졌다.<br>어쩌면 내가 잘못 쓰고 있는 건 아닌지;;<br>강사님이 번역해주신 dan Abramov의 아티클을 다시 읽어봤는데, 잘 사용하고 있는지 아직은 개념이 어렵게 느껴진다. 내일 또 여쭤봐야겠다.</p><h2 id="내일-할-일"><a href="#내일-할-일" class="headerlink" title="내일 할 일"></a>내일 할 일</h2><ul><li>리액트 미니 프로젝트 - social card 만들기(트위터 참고)</li><li>자기소개서 최종 검토하기</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;오늘-한-일&quot;&gt;&lt;a href=&quot;#오늘-한-일&quot; class=&quot;headerlink&quot; title=&quot;오늘 한 일&quot;&gt;&lt;/a&gt;오늘 한 일&lt;/h2&gt;&lt;h3 id=&quot;1-프론트엔드-스쿨과정-리액트&quot;&gt;&lt;a href=&quot;#1-프론트엔드-스쿨과정-리액트&quot; cla
      
    
    </summary>
    
      <category term="TIL" scheme="http://chiabi.github.io/categories/TIL/"/>
    
    
      <category term="TIL" scheme="http://chiabi.github.io/tags/TIL/"/>
    
  </entry>
  
  <entry>
    <title>TIL 20180618</title>
    <link href="http://chiabi.github.io/2018/06/19/TIL/"/>
    <id>http://chiabi.github.io/2018/06/19/TIL/</id>
    <published>2018-06-18T15:49:40.000Z</published>
    <updated>2018-06-18T16:07:20.849Z</updated>
    
    <content type="html"><![CDATA[<h2 id="오늘-한-일"><a href="#오늘-한-일" class="headerlink" title="오늘 한 일"></a>오늘 한 일</h2><h3 id="프로트엔드-스쿨과정-리액트"><a href="#프로트엔드-스쿨과정-리액트" class="headerlink" title="프로트엔드 스쿨과정 - 리액트"></a>프로트엔드 스쿨과정 - 리액트</h3><ul><li>children prop</li><li>로그인 시 예외 처리 (비동기 예외처리)</li><li><code>ref</code>와 “제어되지 않는 컴포넌트”로 폼 바꿔보기</li><li>Presentational component &amp; Container component</li><li>Storybook</li></ul><p>제어되지 않는 컴포넌트 부분은 break week 기간에 잠깐 튜토리얼 따라해 보면서 봤던 부분인데 다시 복습하게 되었다. form의 기본 submit 기능을 사용하게 되면, 따로 이벤트 메서드를 만들지 않아도 되어 코드가 간결해지는 장점이 있지만, 나중에 폼을 쓰게 될 경우 유효성 검사를 하거나 키보드 접근 관련해서 추가적인 처리를 하게 될 것 같아서 대부분의 경우 제어되는 컴포넌트로 하게 되지 않을까 싶다.</p><p>프레젠테이션과 컨테이너 컴포넌트 관련 글은 전날에 올려주셔서 자기 전에 읽어봤는데, 읽어보니 왠지 rgb챌린지 만들면서 이 둘을 잘 구분해서 사용하지 않은 것 같다고 느꼈다. 또 글이 잘 이해가 안되었는데, 오늘 수업을 통해 조금 정리되는 느낌이다.</p><h2 id="오늘-읽은-글"><a href="#오늘-읽은-글" class="headerlink" title="오늘 읽은 글"></a>오늘 읽은 글</h2><ul><li><a href="https://medium.com/@Dev_Bono/context-api%EA%B0%80-redux%EB%A5%BC-%EB%8C%80%EC%B2%B4%ED%95%A0-%EC%88%98-%EC%9E%88%EC%9D%84%EA%B9%8C%EC%9A%94-76a6209b369b" target="_blank" rel="noopener">Context API가 Redux를 대체할 수 있을까요?</a></li><li><a href="https://medium.com/@seungha_kim_IT/presentational-and-container-components-%EB%B2%88%EC%97%AD-1b1fb2e36afb" target="_blank" rel="noopener">Presentiational and Container Components(번역)</a></li><li><a href="https://medium.com/dailyjs/when-do-i-know-im-ready-for-redux-f34da253c85f" target="_blank" rel="noopener">When do I know I’m ready for Redux?</a></li></ul><h2 id="내일-할-일"><a href="#내일-할-일" class="headerlink" title="내일 할 일"></a>내일 할 일</h2><ul><li>내일 수업 내용 복습(<a href="https://reacttraining.com/react-router/web/guides/philosophy" target="_blank" rel="noopener">리액트 라우터</a>를 들어간다고 한다.)</li><li><a href="https://storybook.js.org/" target="_blank" rel="noopener">스토리북</a> 사용해보기</li><li>리덕스 일단 따로 <a href="https://egghead.io/courses/getting-started-with-redux" target="_blank" rel="noopener">Dan abramov의 소개 영상</a> 보면서 감 잡기</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;오늘-한-일&quot;&gt;&lt;a href=&quot;#오늘-한-일&quot; class=&quot;headerlink&quot; title=&quot;오늘 한 일&quot;&gt;&lt;/a&gt;오늘 한 일&lt;/h2&gt;&lt;h3 id=&quot;프로트엔드-스쿨과정-리액트&quot;&gt;&lt;a href=&quot;#프로트엔드-스쿨과정-리액트&quot; class=&quot;
      
    
    </summary>
    
      <category term="TIL" scheme="http://chiabi.github.io/categories/TIL/"/>
    
    
      <category term="TIL" scheme="http://chiabi.github.io/tags/TIL/"/>
    
  </entry>
  
  <entry>
    <title>TIL 20180617</title>
    <link href="http://chiabi.github.io/2018/06/17/TIL/"/>
    <id>http://chiabi.github.io/2018/06/17/TIL/</id>
    <published>2018-06-17T10:13:10.000Z</published>
    <updated>2018-06-18T16:07:21.673Z</updated>
    
    <content type="html"><![CDATA[<h2 id="오늘-한-일"><a href="#오늘-한-일" class="headerlink" title="오늘 한 일"></a>오늘 한 일</h2><h3 id="1-리액트-RGB-Challenge-완성"><a href="#1-리액트-RGB-Challenge-완성" class="headerlink" title="1. 리액트 RGB Challenge 완성"></a>1. 리액트 RGB Challenge 완성</h3><p>공식문서 Context 파트와 지난 수업 시간했던 todo 리스트 실습을 참고해서 context를 사용해 완성했다. 만들다보니 컴포넌트를 굉장히 많이 나누게 되었는데, 그러다보니 DOM API로 단순하게 만들었던 것이 굉장히 복잡해진 것 같아서 내가 제대로 만든 건지 확신이 없다. context는 컬러, 스코어, 결과로 나눠서 각 파일을 따로 만들다.<br><code>setState()</code>로 각 상태를 변화시키는 메서드를 따로 만들었는데, 예를들면 스코어에서는 <code>upScore</code>, <code>reset</code>으로 하나는 score를 추가해주는 것 하나는 score를 다시 0으로 만드는 메서드이다. 결과 context에서는 <code>showResultGood</code>, <code>showResultBad</code>, <code>reset</code>으로 각각 상태에 ‘good’, ‘bad’, 빈 문자열로 수정하는 메서드이다.<br>이렇게 하는게 맞는 것일까 아니면 메서드는 하나만 만들고 나중에 사용할 때 값을 던져주는 것을 인자로 받아서 setState에 던져주도록 만들어야했을까… 이런저런 사용법에 고민이 많아진다.<br>역할과 책임이라는 것에 신경쓰면서 만드려고 했는데, 잘 한건지는 모르겠다. 좀 더 다른 사람들의 코드나 글을 읽어봐야겠다. </p><p>만들면서 그동안 배운것을 다시 정리하고 context를 좀 더 이해하게 되었다. 강사님이 오늘 읽으려고 해두었던 글을 번역해서 올려주셔서 그걸 읽어보고 다시 고민해봐야겠다.</p><h3 id="2-알고리즘-문제-풀이"><a href="#2-알고리즘-문제-풀이" class="headerlink" title="2. 알고리즘 문제 풀이"></a>2. 알고리즘 문제 풀이</h3><p>1일 1알고리즘 하려고 하는데 지키기 힘든 일인 것 같다. 특히나 문제가 어려우면 고민하다가 하루가 지나가버린다. 지금은 리액트를 익히는 것 역시 중요하니까 우선순위를 정해서 신간 분배를 잘 해야 될 것 같다.</p><h2 id="내일-할-일"><a href="#내일-할-일" class="headerlink" title="내일 할 일"></a>내일 할 일</h2><ul><li>리덕스 예습/복습</li><li>리액트로 다른 미니 프로젝트 하기(캘린더 다시 만들어본다거나)</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;오늘-한-일&quot;&gt;&lt;a href=&quot;#오늘-한-일&quot; class=&quot;headerlink&quot; title=&quot;오늘 한 일&quot;&gt;&lt;/a&gt;오늘 한 일&lt;/h2&gt;&lt;h3 id=&quot;1-리액트-RGB-Challenge-완성&quot;&gt;&lt;a href=&quot;#1-리액트-RGB-Chall
      
    
    </summary>
    
      <category term="TIL" scheme="http://chiabi.github.io/categories/TIL/"/>
    
    
      <category term="TIL" scheme="http://chiabi.github.io/tags/TIL/"/>
    
  </entry>
  
  <entry>
    <title>Longet Common Prefix</title>
    <link href="http://chiabi.github.io/2018/06/17/Longet-Common-Prefix/"/>
    <id>http://chiabi.github.io/2018/06/17/Longet-Common-Prefix/</id>
    <published>2018-06-17T09:08:46.000Z</published>
    <updated>2018-07-09T14:22:56.925Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/longest-common-prefix/description/" target="_blank" rel="noopener">leetcode 문제링크</a></p><blockquote><p>Write a function to find the longest common prefix string amongst an array of strings.</p><p>If there is no common prefix, return an empty string “”.</p><p><strong>Example 1:</strong></p><ul><li>Input: [“flower”,”flow”,”flight”]</li><li>Output: “fl”</li></ul><p><strong>Example 2:</strong></p><ul><li>Input: [“dog”,”racecar”,”car”]</li><li>Output: “”</li><li>Explanation: There is no common prefix among the input strings.<br><strong>Note:</strong><br>All given inputs are in lowercase letters a-z.</li></ul></blockquote><h2 id="나의-풀이"><a href="#나의-풀이" class="headerlink" title="나의 풀이"></a>나의 풀이</h2><p>더 좋은 방법이 생각나지 않아서 일단 난폭하게 for 문 두 번 돌려서 풀어보기로 했다. 이렇게 하지 않고 푸는 방법이 있을까… 생각이 안 난다.<br>배열에 아무것도 들어있지 않은 경우도 고려한 문제였던 모양이다. 계속 런타임 에러가 나길래 보니 빈 배열이 들어가고 있었다.<br>for문을 두 번 돌렸지만, 어차피 prefix 찾는 거라서 앞에서 일치하는 경우 외에는 버리기 때문에 return으로 종료시켜 버렸다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 64ms</span></span><br><span class="line"><span class="keyword">var</span> longestCommonPrefix = <span class="function"><span class="keyword">function</span>(<span class="params">strs</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> first = strs[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">if</span> (first == <span class="literal">null</span>) <span class="keyword">return</span> <span class="string">''</span>;</span><br><span class="line">  <span class="keyword">let</span> str = <span class="string">''</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>, il = first.length; i &lt; il; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> j = <span class="number">1</span>, jl = strs.length; j &lt; jl; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span>(first[i] !== strs[j][i]) &#123;</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    str += first[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> str;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 60ms</span></span><br><span class="line"><span class="keyword">var</span> longestCommonPrefix = <span class="function"><span class="keyword">function</span>(<span class="params">strs</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> first = strs[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">if</span> (first == <span class="literal">null</span>) <span class="keyword">return</span> <span class="string">''</span>;</span><br><span class="line">  <span class="keyword">const</span> newStrs = strs.slice(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">let</span> str = <span class="string">''</span>;</span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(i &lt; first.length) &#123;</span><br><span class="line">    <span class="keyword">if</span>(newStrs.every(<span class="function">(<span class="params">item</span>) =&gt;</span> item[i] === first[i])) &#123;</span><br><span class="line">      str += first[i]</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line">    i++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>배열의 every 메서드와 while로 풀어봤다. 속도가 크게 개선되지는 않았다.</p><h2 id="다른-사람-풀이"><a href="#다른-사람-풀이" class="headerlink" title="다른 사람 풀이"></a>다른 사람 풀이</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 50ms</span></span><br><span class="line"><span class="keyword">var</span> longestCommonPrefix = <span class="function"><span class="keyword">function</span>(<span class="params">strs</span>) </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span>(!strs.length) <span class="keyword">return</span> <span class="string">''</span>;</span><br><span class="line">  <span class="keyword">if</span>(strs.length === <span class="number">1</span>) <span class="keyword">return</span> strs[<span class="number">0</span>];</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">let</span> prefix = strs[<span class="number">0</span>];</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i <span class="keyword">in</span> strs) &#123;</span><br><span class="line">    <span class="keyword">while</span>(strs[i].indexOf(prefix) !== <span class="number">0</span>) &#123;</span><br><span class="line">      prefix = prefix.substring(<span class="number">0</span>, prefix.length - <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">if</span>(!prefix.length) <span class="keyword">return</span> <span class="string">''</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">   <span class="keyword">return</span> prefix; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>나와 다른 접근법이다. 나는 배열에 있는 요소의 인덱스를 앞에서부터 돌면서 그 인덱스의 문자열이 모두 같으면 <code>str</code>에 더해서 prefix를 만들어 반환했는데,<br>여기는 일단 첫번째 문자열을 prefix라 가정하고 시작한다. 배열의 요소를 하나씩 순회하면서 prefix와 일치하는 문자열을 가지지 않으면 prefix에서 거꾸로 문자를 줄여가며 대조한다.</p><p>그렇다면 첫번째 문자열은 이미 prefix인데 for in문으로 첫번째 요소를 굳이 돌 필요가 있나 했는데, for loop로 인덱스 1부터 도는 것보다 어차피 while문 조건에 걸려서 다음 요소로 넘어가니까 for in문을 쓰는 게 더 빠른가보다.(환경에 따라 다를 수 있겠지만)</p><p>핵심은 <code>indexOf</code>의 사용인 것 같다. 문자열 하나씩 더하는 것보단 문자열 뭉치가 있는 지 확인하는 것이 더 효율적이니까.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 56ms</span></span><br><span class="line"><span class="keyword">var</span> longestCommonPrefix = <span class="function"><span class="keyword">function</span>(<span class="params">strs</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!strs.length) <span class="keyword">return</span> <span class="string">''</span>;</span><br><span class="line">  <span class="keyword">if</span>(strs.length === <span class="number">1</span>) <span class="keyword">return</span> strs[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">let</span> prefix = strs[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>, l = strs.length; i &lt; l; i++) &#123;</span><br><span class="line">    <span class="keyword">while</span>(strs[i].indexOf(prefix) !== <span class="number">0</span>) &#123;</span><br><span class="line">      prefix = prefix.substring(<span class="number">0</span>, prefix.length - <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">if</span>(!prefix.length) <span class="keyword">return</span> <span class="string">''</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> prefix;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/longest-common-prefix/description/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;leetcode 문제링크&lt;/a&gt;&lt;/p&gt;
&lt;blockquo
      
    
    </summary>
    
      <category term="Algorithm" scheme="http://chiabi.github.io/categories/Algorithm/"/>
    
    
      <category term="algorithm" scheme="http://chiabi.github.io/tags/algorithm/"/>
    
      <category term="leetcode" scheme="http://chiabi.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>TIL 20180616</title>
    <link href="http://chiabi.github.io/2018/06/16/TIL-1/"/>
    <id>http://chiabi.github.io/2018/06/16/TIL-1/</id>
    <published>2018-06-16T11:54:09.000Z</published>
    <updated>2018-06-16T14:27:53.512Z</updated>
    
    <content type="html"><![CDATA[<h2 id="오늘-한-일"><a href="#오늘-한-일" class="headerlink" title="오늘 한 일"></a>오늘 한 일</h2><h3 id="Context-복습"><a href="#Context-복습" class="headerlink" title="Context 복습"></a>Context 복습</h3><p>context를 복습하면서 리액트를 단순하게 사용해본 RGB 챌린지를 수정하고 있다. 리액트 공식문서를 읽어보고, velopert님의 context API관련 예제도 따라해봤다.<br>공식문서를 읽어보니 어떻게 쓰는 지는 이해가 되는데, 그래서 어디까지 context를 써주는 것이 좋은지, 코드를 어떻게 관리되도록 설계하는 것이 좋은지는 아직 감이 안잡힌다.<br>일단 context를 활용해서 전체적으로 이벤트까지 완료한 뒤에 강사님이 공유해 주신 Dan Abramov의 ‘Presentational and Container Components’라는 글을 다시 읽어봐야겠다.</p><p>예제를 따라하는 중에 <code>import React, {Component} from &#39;react&#39;</code> 이하 클래스를 만드는 거나 export시키는 부분은 react 사용하면서 거의 패턴처럼 치게 되니까, vscode의 사용자 코드 조각에 스니펫으로 만들어 두었다.</p><h2 id="내일-할-일"><a href="#내일-할-일" class="headerlink" title="내일 할 일"></a>내일 할 일</h2><ul><li>RGB 챌린지 context 완성하기</li><li>Redux 예습하기</li><li>소프트웨어 공학 시간에 정리한 글 다시 다듬어서 올리기</li></ul><hr><p>날이 더워졌다. 에어컨 바람이 간절해진다. 더워질수록 체력 관리를 해야겠다. ‘앞으로 할 일’이라고 썼던 것을 ‘내일 할 일’로 쓰려고 한다. 다 수행하지 못하더라도 내일 할 일로 정해놓으면 더 강제적으로 하게 될 것 같다. </p><p>일주일간 블로그를 해보니 장단점이 있다. 일단 글을 좀 더 다듬게 되고, 글 자체가 정제되어 보이는 장점이 있다.<br>단점은 그냥 깃헙에는 자유롭게 덜 완성된 글이나 정리도 올렸는데, 블로그는 그렇게 하는 것이 쉽지 않아졌다. 물론 누가 잘못된 정보라고 지적하는 게 두려운 것은 아니다. 누가 내 글에 관심을 가져주고, 내가 잘못 알고 있는 부분을 바로잡아 주는 것은 감사한 일이나, 혹시라도 내가 잘못된 정보를 제공하지는 않을까하는 우려도 된다.<br>그런데 사실 그런 부분을 걱정하기 이전에 검색 엔진 최적화 방법을 알아봐야겠다…;;</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;오늘-한-일&quot;&gt;&lt;a href=&quot;#오늘-한-일&quot; class=&quot;headerlink&quot; title=&quot;오늘 한 일&quot;&gt;&lt;/a&gt;오늘 한 일&lt;/h2&gt;&lt;h3 id=&quot;Context-복습&quot;&gt;&lt;a href=&quot;#Context-복습&quot; class=&quot;headerli
      
    
    </summary>
    
      <category term="TIL" scheme="http://chiabi.github.io/categories/TIL/"/>
    
    
      <category term="TIL" scheme="http://chiabi.github.io/tags/TIL/"/>
    
  </entry>
  
  <entry>
    <title>TIL 20180615</title>
    <link href="http://chiabi.github.io/2018/06/16/TIL/"/>
    <id>http://chiabi.github.io/2018/06/16/TIL/</id>
    <published>2018-06-15T16:13:22.000Z</published>
    <updated>2018-06-16T14:32:25.736Z</updated>
    
    <content type="html"><![CDATA[<h2 id="오늘-한-일"><a href="#오늘-한-일" class="headerlink" title="오늘 한 일"></a>오늘 한 일</h2><h3 id="프론트엔드-개발-과정-특강-소프트웨어-공학"><a href="#프론트엔드-개발-과정-특강-소프트웨어-공학" class="headerlink" title="프론트엔드 개발 과정 - 특강 [소프트웨어 공학]"></a>프론트엔드 개발 과정 - 특강 [소프트웨어 공학]</h3><p>어제 한 과제는 기능 명세가 아니었던 것 같다. 화면설계 전 단계였던듯… why? 도출보다는 상세한 기능 기술이었던 것 같다…<br>수업시간에 클라이언트가 블록체인 거래소를 만들려고 한다는 상황을 가정해서 요구사항을 분석하고, 클라이언트(강사님)에게 질문하는 식으로 진행되었는데, 블록체인이라는 기술 자체를 잘 몰라서 질문을 할 수가 없었다.<br>웹 사이트를 볼때 그냥 보는 것이 아니라 어떤 기술을 사용했고, 어떤 콘텐츠로 이루어져있는지 분석해봐야겠다. 그리고 블록체인이라는 기술 자체에도 관심을 기울여야겠다.</p><h2 id="앞으로-할-일"><a href="#앞으로-할-일" class="headerlink" title="앞으로 할 일"></a>앞으로 할 일</h2><ul><li>RGB 챌린지 context 활용하기</li><li>Redux 미리 예습하기</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;오늘-한-일&quot;&gt;&lt;a href=&quot;#오늘-한-일&quot; class=&quot;headerlink&quot; title=&quot;오늘 한 일&quot;&gt;&lt;/a&gt;오늘 한 일&lt;/h2&gt;&lt;h3 id=&quot;프론트엔드-개발-과정-특강-소프트웨어-공학&quot;&gt;&lt;a href=&quot;#프론트엔드-개발-과정-특강
      
    
    </summary>
    
      <category term="TIL" scheme="http://chiabi.github.io/categories/TIL/"/>
    
    
      <category term="TIL" scheme="http://chiabi.github.io/tags/TIL/"/>
    
  </entry>
  
  <entry>
    <title>Palindrome Number</title>
    <link href="http://chiabi.github.io/2018/06/15/Palindrome-Number/"/>
    <id>http://chiabi.github.io/2018/06/15/Palindrome-Number/</id>
    <published>2018-06-14T17:37:32.000Z</published>
    <updated>2018-06-17T09:10:54.176Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/palindrome-number/description/" target="_blank" rel="noopener">leetcode 문제링크</a></p><blockquote><p>Determine whether an integer is a palindrome. An integer is a palindrome when it reads the same backward as forward.</p><p><strong>Example 1:</strong></p><ul><li>Input: 121</li><li>Output: true</li></ul><p><strong>Example 2:</strong><br>Input: -121<br>Output: false<br>Explanation: From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome.</p><p><strong>Example 3:</strong><br>Input: 10<br>Output: false<br>Explanation: Reads 01 from right to left. Therefore it is not a palindrome.</p><p><strong>Follow up:</strong><br>Coud you solve it without converting the integer to a string?</p></blockquote><p><del>예?? 이걸 문자열화 하지 말고 풀라구요???</del></p><h2 id="나의-풀이"><a href="#나의-풀이" class="headerlink" title="나의 풀이"></a>나의 풀이</h2><p>난이도 easy만 먼저 풀어보는데 속도에 집착하다보니 난이도가 easy가 아닌 것만 같은 기분…</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 304ms </span></span><br><span class="line"><span class="keyword">var</span> isPalindrome = <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> str = x.toString();</span><br><span class="line">  <span class="keyword">const</span> reverseStr = str.split(<span class="string">''</span>).reverse().join(<span class="string">''</span>);</span><br><span class="line">  <span class="keyword">return</span> str === reverseStr</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>Hint: Beware of overflow when you reverse the integer.</p></blockquote><p>네..그렇군요… 뒤집는 건 주의해야겠군요…세상에…<br>아래는 while문을 통해 앞 / 뒤로 접근해서 비교하도록 하는 방법인데,<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 268ms</span></span><br><span class="line"><span class="keyword">var</span> isPalindrome = <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> str = x.toString();</span><br><span class="line">  <span class="keyword">const</span> l = str.length - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> result = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">while</span>(i &lt;= l) &#123;</span><br><span class="line">    <span class="keyword">if</span>(str[i] !== str[l - i]) &#123;</span><br><span class="line">      <span class="keyword">return</span> (result = <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    i++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>반으로 나눠야 중복되는 비교를 안하겠구나 생각해서 아래와 같이 수정했지만 속도가 크게 개선되지는 않았다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 260ms 속도 개선이 별로..</span></span><br><span class="line"><span class="keyword">var</span> isPalindrome = <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> str = x.toString();</span><br><span class="line">  <span class="keyword">const</span> l = str.length;</span><br><span class="line">  <span class="keyword">const</span> half = <span class="built_in">Math</span>.floor(l / <span class="number">2</span>);</span><br><span class="line">  <span class="keyword">const</span> strF = str.slice(<span class="number">0</span>, half);</span><br><span class="line">  <span class="keyword">const</span> strB = str.slice(l % <span class="number">2</span> === <span class="number">0</span> ? half : half + <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> result = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">while</span>(i &lt; half) &#123;</span><br><span class="line">    <span class="keyword">if</span>(strF[i] !== strB[(half - <span class="number">1</span>) - i]) &#123;</span><br><span class="line">      <span class="keyword">return</span> result = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    i++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>혹시나 해서 reverse 메소드를 사용하는 방법을 반으로 나눠서 하는 방법으로 다시 풀어봤다.<br>300ms가 280ms로 속도가 개선되었으나 앞의 풀이 방법에 비하면 느리다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 280ms</span></span><br><span class="line"><span class="keyword">var</span> isPalindrome = <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> str = x.toString();</span><br><span class="line">  <span class="keyword">const</span> l = str.length;</span><br><span class="line">  <span class="keyword">if</span> (l === <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> half = <span class="built_in">Math</span>.floor(l / <span class="number">2</span>);</span><br><span class="line">  <span class="keyword">const</span> strF = str.slice(<span class="number">0</span>, half);</span><br><span class="line">  <span class="keyword">const</span> strB = str.slice(l % <span class="number">2</span> === <span class="number">0</span> ? half : half + <span class="number">1</span>).split(<span class="string">''</span>).reverse().join(<span class="string">''</span>);</span><br><span class="line">  <span class="keyword">return</span> strF === strB</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>문자열화하지 않고 숫자인 상태에서 풀면 좀 더 빠를까해서 아래와 같이 풀었는데, 더 느려졌다. 아마 이 역시 주어진 수를 반으로 나눠서 푸는 게 아니라서 그런 것 같다.(수의 길이(?)만큼 비교하게 된다.)<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 300ms 아악 더 느려졌다.</span></span><br><span class="line"><span class="keyword">var</span> isPalindrome = <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(x &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(x &lt; <span class="number">10</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> xClone = x;</span><br><span class="line">  <span class="keyword">const</span> arr = [];</span><br><span class="line">  <span class="keyword">while</span>(xClone) &#123;</span><br><span class="line">    <span class="keyword">const</span> X = xClone % <span class="number">10</span>;</span><br><span class="line">    xClone = <span class="built_in">parseInt</span>(xClone / <span class="number">10</span>);</span><br><span class="line">    arr.push(X % <span class="number">10</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> x === <span class="built_in">parseInt</span>(arr.join(<span class="string">''</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>뭔가 숫자를 반으로 쪼갤 수 있으면 좋겠는데, 이 부분은 방법이 잘 생각나지 않아서 solution을 보기로 했다.<br>아래는 solution을 참고한 풀이  </p><blockquote><p>Approach 1: Revert half of the number<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C#</span></span><br><span class="line"><span class="keyword">while</span>(x &gt; revertedNumber) &#123;</span><br><span class="line">    revertedNumber = revertedNumber * <span class="number">10</span> + x % <span class="number">10</span>;</span><br><span class="line">    x /= <span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><p>이부분을 통해 수를 반으로 나눠 반복문 안에서 비교할 수 있도록 하는 방법이다.<br>C#의 문법을 잘 모르지만 C#은 알아서 소수점 아래는 제거해주는 건지;; 아무튼 소수점 아래가 생겨버리므로 나는 JavaScript로 풀어야하니까 parseInt를 통해 정수로 계산되도록 했다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 256ms</span></span><br><span class="line"><span class="keyword">var</span> isPalindrome = <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> xC = x;</span><br><span class="line">  <span class="keyword">if</span>(x &lt; <span class="number">0</span> || (x % <span class="number">10</span> === <span class="number">0</span> &amp;&amp; x !== <span class="number">0</span>)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (x &lt; <span class="number">10</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> revert = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(xC &gt; revert) &#123;</span><br><span class="line">    revert = <span class="built_in">parseInt</span>(revert * <span class="number">10</span> + xC % <span class="number">10</span>);</span><br><span class="line">    xC = <span class="built_in">parseInt</span>(xC / <span class="number">10</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> xC === revert || xC === <span class="built_in">parseInt</span>(revert / <span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p><strong>Complexity Analysis</strong></p><ul><li>Time complexity : <math><mrow><mi>O</mi><mo>(</mo><msub><mi>log</mi><mn>10</mn></msub><mi mathvariant="monospace">n</mi><mo>)</mo></mrow></math><br>We divided the input by 10 for every iteration, so the time complexity is <math><mrow><mi>O</mi><mo>(</mo><msub><mi>log</mi><mn>10</mn></msub><mi mathvariant="monospace">n</mi><mo>)</mo></mrow></math></li><li>Space complexity : <math><mrow><mi>O</mi><mo>(</mo><mn>1</mn><mo>)</mo></mrow></math></li></ul></blockquote><p>라는데, 복잡성 공부를 해야겠다… 댓글에서는 ‘왜 <math><mrow><mi>O</mi><mo>(</mo><msub><mi>log</mi><mn>10</mn></msub><mi mathvariant="monospace">n</mi><mo>)</mo></mrow></math>이냐 <math><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow></math>이 맞다’, ‘아니다 솔루션 저자가 맞다’로 의견이 분분한 듯한데 아직 잘 모르겠다;;</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/palindrome-number/description/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;leetcode 문제링크&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;

      
    
    </summary>
    
      <category term="Algorithm" scheme="http://chiabi.github.io/categories/Algorithm/"/>
    
    
      <category term="algorithm" scheme="http://chiabi.github.io/tags/algorithm/"/>
    
      <category term="leetcode" scheme="http://chiabi.github.io/tags/leetcode/"/>
    
  </entry>
  
</feed>
